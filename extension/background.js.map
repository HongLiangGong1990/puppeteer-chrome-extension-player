{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.js","webpack:///./lib/Extension.js","webpack:///./lib/Launcher.js","webpack:///./lib/Puppeteer.js","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/debug/src/browser.js","webpack:///./node_modules/debug/src/debug.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/mime/Mime.js","webpack:///./node_modules/mime/index.js","webpack:///./node_modules/ms/index.js","webpack:///./node_modules/path-browserify/index.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/puppeteer-core/lib/Browser.js","webpack:///./node_modules/puppeteer-core/lib/Connection.js","webpack:///./node_modules/puppeteer-core/lib/Coverage.js","webpack:///./node_modules/puppeteer-core/lib/Dialog.js","webpack:///./node_modules/puppeteer-core/lib/ElementHandle.js","webpack:///./node_modules/puppeteer-core/lib/EmulationManager.js","webpack:///./node_modules/puppeteer-core/lib/Errors.js","webpack:///./node_modules/puppeteer-core/lib/ExecutionContext.js","webpack:///./node_modules/puppeteer-core/lib/FrameManager.js","webpack:///./node_modules/puppeteer-core/lib/Input.js","webpack:///./node_modules/puppeteer-core/lib/Multimap.js","webpack:///./node_modules/puppeteer-core/lib/NavigatorWatcher.js","webpack:///./node_modules/puppeteer-core/lib/NetworkManager.js","webpack:///./node_modules/puppeteer-core/lib/Page.js","webpack:///./node_modules/puppeteer-core/lib/Pipe.js","webpack:///./node_modules/puppeteer-core/lib/Target.js","webpack:///./node_modules/puppeteer-core/lib/TaskQueue.js","webpack:///./node_modules/puppeteer-core/lib/Tracing.js","webpack:///./node_modules/puppeteer-core/lib/USKeyboardLayout.js","webpack:///./node_modules/puppeteer-core/lib/Worker.js","webpack:///./node_modules/puppeteer-core/lib/helper.js","webpack:///(webpack)/buildin/global.js","webpack:///external \"ws\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,yCAAyC,QAAQ;AACjD;AACA;AACA,yBAAyB,sBAAsB;;AAE/C;AACA,CAAC;;;;;;;;;;;;AClBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,qBAAqB;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD,yCAAyC,aAAa;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB;AACA,OAAO,UAAU;AACjB,OAAO,aAAa;;AAEpB;AACA;AACA,aAAa,oBAAoB,0BAA0B,GAAG;AAC9D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA,KAAK;AACL;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA,OAAO,SAAS;AAChB;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc,uDAAuD;AACrE,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5vDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;;;;;;ACnFA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,GAAG,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;;;;;;;;;;;;ACxFA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/NA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,iBAAiB;AACxB,OAAO,OAAO;AACd;AACA,OAAO,UAAU;;AAEjB;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB,aAAa,oBAAoB;AACjC,aAAa,wBAAwB;AACrC,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;;AAEA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,iEAAiE,yCAAyC;AAC1G;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB,aAAa,oBAAoB;AACjC,aAAa,wBAAwB;AACrC,aAAa,YAAY;AACzB;AACA;AACA;AACA,wDAAwD,eAAe;AACvE;AACA;;AAEA;AACA,aAAa,sCAAsC;AACnD;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,0CAA0C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,WAAW,SAAS,uDAAuD,6DAA6D;AACxI;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;AC1SlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,uBAAuB;AACpC,aAAa,uBAAuB;AACpC,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,+BAA+B;AAC5C,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc,mEAAmE,EAAE;AAClG;AACA;;AAEA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,0BAA0B;AAC1B;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA,+BAA+B,4CAA4C;AAC3E,KAAK;AACL;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,sEAAsE,gBAAgB;AACtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,2BAA2B;AACxC,cAAc;AACd;AACA;AACA,WAAW,UAAU,6CAA6C,8BAA8B;AAChG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,eAAe,cAAc,mEAAmE,EAAE;AAClG;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,0BAA0B;AAC1B;AACA,yDAAyD,OAAO,qCAAqC,iBAAiB;AACtH;AACA,oCAAoC,mBAAmB;AACvD;AACA,yDAAyD,oCAAoC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+BAA+B,4CAA4C;AAC3E,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,2BAA2B;AACxF;;AAEA;AACA;AACA,sEAAsE,gBAAgB;AACtF;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ,6BAA6B;AACjD,YAAY;AACZ;AACA;AACA,mCAAmC,OAAO,KAAK,qBAAqB;AACpE;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;AC1RlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,2BAA2B;;AAElC,OAAO,sBAAsB;;AAE7B;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS,2BAA2B,EAAE;AACpD;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iCAAiC;AAC3F;AACA,sDAAsD,WAAW;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,uCAAuC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,yBAAyB;AACrG;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qCAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kCAAkC;AAC3G;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,SAAS,mDAAmD,EAAE;AACzE,YAAY,SAAS,yBAAyB;AAC9C;AACA;AACA;AACA;AACA,iBAAiB,4CAA4C;AAC7D,iBAAiB,0CAA0C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAe;;AAEtB;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS;AAChB,OAAO,2BAA2B;;AAElC;AACA;AACA,aAAa,4BAA4B;AACzC,aAAa,sBAAsB;AACnC,aAAa,+BAA+B;AAC5C,aAAa,gBAAgB;AAC7B,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAuD;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,gCAAgC,uDAAuD;AACvF;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc,WAAW,qBAAqB;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA,OAAO,uBAAuB;AAC9B,OAAO,uBAAuB;AAC9B,OAAO,uBAAuB;AAC9B,OAAO;AACP;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA,0BAA0B;AAC1B;AACA,WAAW,KAAK;AAChB;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,0BAA0B,EAAE;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW,oDAAoD;AAC7E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,gDAAgD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,eAAe;AACf;AACA,+BAA+B;AAC/B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;AACA;;AAEA;;AAEA;AACA;;AAEA,WAAW,kBAAkB,eAAe,EAAE;;AAE9C,iCAAiC;AACjC;AACA;;AAEA,kEAAkE;AAClE;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;;;;;;;;;;;;ACxYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,oBAAoB;AACjC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD,sDAAsD,sCAAsC,IAAI;AAChG;;AAEA;AACA,+DAA+D,8DAA8D;AAC7H;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;ACrDlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAe;;AAEtB;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,8CAA8C;AAC3D,aAAa,mDAAmD;AAChE,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,gBAAgB;AAC7B,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,gBAAgB;AAC7B,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA,oCAAoC,sBAAsB;;AAE1D;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA,aAAa,uCAAuC;AACpD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,yCAAyC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB,gBAAgB;AAChB;AACA,cAAc;AACd;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B,aAAa,sBAAsB;AACnC,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,0CAA0C,aAAa,EAAE;AACzD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;;;;;;;;;;;AC3PlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,eAAe;AACtB,OAAO,2BAA2B;AAClC,OAAO,cAAc;AACrB,OAAO,aAAa;;AAEpB;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,yBAAyB;AACtC,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA,eAAe,gCAAgC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,qCAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,+BAA+B;AAC5C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,yBAAyB;AACxC;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA,eAAe,aAAa;AAC5B;;AAEA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+CAA+C,IAAI;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8CAA8C,IAAI;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,YAAY,eAAe;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE,iDAAiD,kBAAkB;AACnE;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,0BAA0B,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,yBAAyB;AACtC,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,cAAc;AACd;AACA,mDAAmD;AACnD;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA,aAAa,gBAAgB;AAC7B,aAAa,SAAS;AACtB,cAAc;AACd;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B,IAAI,gBAAgB,GAAG,qCAAqC;AAChH;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;;AAEzC;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2DAA2D,MAAM,mBAAmB,QAAQ;AAC5F;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;AC7/BlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAe;AACtB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,aAAa,EAAE;AAC7B;AACA,6BAA6B,kBAAkB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,UAAU;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA,iDAAiD,WAAW;AAC5D;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,0BAA0B,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,SAAS;AACtB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;;;;;;;;;;;AC/SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAe;AACtB,OAAO,aAAa;AACpB,OAAO,aAAa;;AAEpB;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,iBAAiB;AAChC,eAAe,eAAe;AAC9B,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;ACzIlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,2BAA2B;AAClC;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,yDAAyD;AACxE;AACA,eAAe,wBAAwB;AACvC;;AAEA;;AAEA,eAAe,EAAE,oCAAoC;AACrD;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA,eAAe,0BAA0B;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE,oCAAoC;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA,kEAAkE,IAAI,uBAAuB,aAAa;AAC1G;AACA;AACA,4DAA4D,kCAAkC;AAC9F;;AAEA;AACA,cAAc;AACd;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA,6DAA6D,YAAY;AACzE;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA,qDAAqD,uBAAuB;AAC5E,2DAA2D,SAAS;AACpE;AACA;;AAEA;AACA,aAAa,2CAA2C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,4CAA4C;AACzD;AACA;AACA;AACA,iBAAiB,4CAA4C;AAC7D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,aAAa,mBAAmB,yBAAyB;AACzD;AACA;AACA,gCAAgC;AAChC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,2CAA2C;AACxD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,gDAAgD;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,0BAA0B;AACvC,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,0CAA0C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,yCAAyC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,uCAAuC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,0BAA0B;AACvC,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,EAAE,6EAA6E;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kGAAkG,OAAO,iCAAiC,QAAQ;;AAElJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,WAAW,GAAG,WAAW;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0BAA0B;AACrC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;;AC/xBlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,eAAe;AACtB,OAAO,iBAAiB;AACxB,OAAO,OAAO;AACd,OAAO,iBAAiB;AACxB,OAAO,aAAa;AACpB,OAAO,6BAA6B;AACpC;AACA,OAAO,2BAA2B;AAClC,OAAO,SAAS;AAChB,OAAO,OAAO;;AAEd;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,kBAAkB;AAC/B,aAAa,QAAQ;AACrB,aAAa,oBAAoB;AACjC,aAAa,qBAAqB;AAClC,cAAc;AACd;AACA;;AAEA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA,2CAA2C,gDAAgD;AAC3F,qDAAqD,gBAAgB;AACrE,sCAAsC;AACtC,sCAAsC;AACtC,uCAAuC;AACvC,0CAA0C;AAC1C,kCAAkC;AAClC;AACA;AACA,kEAAkE,eAAe;AACjF;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC,aAAa,kBAAkB;AAC/B,aAAa,yBAAyB;AACtC,aAAa,QAAQ;AACrB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;;AAEA;;AAEA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,gCAAgC;AAC7C;AACA;AACA,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,2CAA2C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,oBAAoB;AACjC,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,kBAAkB;AAC/B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA,KAAK;AACL;AACA;AACA,qDAAqD,iBAAiB;AACtE;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB;AACA;AACA;AACA,8DAA8D,KAAK,YAAY,KAAK;AACpF;;AAEA;AACA,mDAAmD,WAAW;AAC9D,sEAAsE,mBAAmB;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE,oCAAoC;AACnD;AACA;AACA;AACA;;AAEA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,qCAAqC;AAClD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA,aAAa,0CAA0C;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,uCAAuC;AACpD;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,2CAA2C,kDAAkD;;AAE7F;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,8BAA8B;AAC9B;;AAEA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,sBAAsB;AACrC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E,iDAAiD,mBAAmB,MAAM,IAAI;AAC9E,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,SAAS;AACtB,cAAc;AACd;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,SAAS;AACtB,cAAc;AACd;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,qEAAqE,kBAAkB;AACvF;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,kDAAkD,UAAU;AAC5D;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;;AAEA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,UAAU;AACvB;AACA;AACA;AACA,sEAAsE,SAAS;AAC/E;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,yDAAyD,wBAAwB;AACjF;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA,sDAAsD,iCAAiC;AACvF,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,iBAAiB,sCAAsC;AACvD,6CAA6C,sCAAsC,IAAI;AACvF,qEAAqE,8DAA8D;AACnI;;AAEA;AACA,8EAA8E,SAAS,yBAAyB,EAAE;AAClH,sEAAsE,yCAAyC;AAC/G;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE,qCAAqC,EAAE;AACtD;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL,iEAAiE,mCAAmC;AACpG;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,0BAA0B,EAAE;AAC1C;AACA;AACA;AACA;;AAEA;AACA,aAAa,yBAAyB;AACtC,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,cAAc;AACd;AACA,mDAAmD;AACnD;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA,aAAa,WAAW;AACxB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,cAAc;AACd;AACA,4CAA4C;AAC5C;AACA;AACA;;AAEA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,OAAO;AAClB;AACA,WAAW,uBAAuB;AAClC,UAAU,uBAAuB;AACjC,YAAY,sBAAsB;AAClC,WAAW,sBAAsB;AACjC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0BAA0B;AACrC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,GAAG;AACH,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,kBAAkB;AAChC;;;AAGA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;AAGA,kBAAkB;AAClB;;;;;;;;;;;;;AC7qCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,OAAO;AACd;;AAEA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpEA,OAAO,KAAK;AACZ,OAAO,OAAO;;AAEd;AACA;AACA,aAAa,4BAA4B;AACzC,aAAa,0BAA0B;AACvC,aAAa,4CAA4C;AACzD,aAAa,QAAQ;AACrB,aAAa,oBAAoB;AACjC,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;;AAEA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB;;;;;;;;;;;;ACxGlB;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA,kBAAkB,W;;;;;;;;;;;AChBlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA;AACA,UAAU;AACV;AACA;AACA,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,YAAY,gCAAgC;AAC5C,YAAY,gCAAgC;AAC5C,YAAY,+CAA+C;AAC3D,WAAW,4CAA4C;AACvD,gBAAgB,sDAAsD;AACtE,UAAU,0CAA0C;AACpD,cAAc,sGAAsG;AACpH,kBAAkB,kFAAkF;AACpG,YAAY,6DAA6D;AACzE,SAAS,6DAA6D;AACtE,SAAS,6DAA6D;AACtE,gBAAgB,kEAAkE;AAClF,iBAAiB,mEAAmE;AACpF,kBAAkB,sEAAsE;AACxF,mBAAmB,uEAAuE;AAC1F,cAAc,8DAA8D;AAC5E,eAAe,+DAA+D;AAC9E,YAAY,+CAA+C;AAC3D,eAAe,qDAAqD;AACpE,aAAa,iDAAiD;AAC9D,cAAc,mDAAmD;AACjE,iBAAiB,yDAAyD;AAC1E,YAAY,2CAA2C;AACvD,cAAc,uGAAuG;AACrH,aAAa,iDAAiD;AAC9D,cAAc,wGAAwG;AACtH,eAAe,qDAAqD;AACpE,UAAU,2CAA2C;AACrD,cAAc,mGAAmG;AACjH,WAAW,6CAA6C;AACxD,cAAc,qGAAqG;AACnH,gBAAgB,uDAAuD;AACvE,cAAc,0GAA0G;AACxH,cAAc,wGAAwG;AACtH,cAAc,mDAAmD;AACjE,iBAAiB,yDAAyD;AAC1E,cAAc,2GAA2G;AACzH,cAAc,yGAAyG;AACvH,gBAAgB,uDAAuD;AACvE,aAAa,iDAAiD;AAC9D,WAAW,gDAAgD;AAC3D,kBAAkB,2DAA2D;AAC7E,aAAa,iDAAiD;AAC9D,cAAc,sGAAsG;AACpH,aAAa,iDAAiD;AAC9D,oBAAoB,6GAA6G;AACjI,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,6DAA6D;AAC1E,aAAa,8DAA8D;AAC3E,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,WAAW,2DAA2D;AACtE,eAAe,iDAAiD;AAChE,gBAAgB,kDAAkD;AAClE,kBAAkB,2DAA2D;AAC7E,qBAAqB,oEAAoE;AACzF,gBAAgB,+DAA+D;AAC/E,qBAAqB,oEAAoE;AACzF,mBAAmB,kEAAkE;AACrF,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,SAAS,0CAA0C;AACnD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,UAAU,4CAA4C;AACtD,cAAc,oDAAoD;AAClE,iBAAiB,0DAA0D;AAC3E,sBAAsB,oEAAoE;AAC1F,sBAAsB,oEAAoE;AAC1F,oBAAoB,gEAAgE;AACpF,qBAAqB,kEAAkE;AACvF,yBAAyB,0EAA0E;AACnG,gBAAgB,wDAAwD;AACxE,qBAAqB,kEAAkE;AACvF,gBAAgB,+DAA+D,EAAE;AACjF,YAAY,6DAA6D;AACzE,kBAAkB,iEAAiE;AACnF,YAAY,8DAA8D;AAC1E,YAAY,6DAA6D;AACzE,aAAa,8DAA8D;AAC3E,YAAY,6DAA6D;AACzE,gBAAgB,iEAAiE;AACjF,kBAAkB,qDAAqD,cAAc;AACrF,gBAAgB,kEAAkE;AAClF,mBAAmB,sDAAsD,cAAc;AACvF,YAAY,8DAA8D;AAC1E,eAAe,sDAAsD;AACrE,YAAY,gDAAgD;AAC5D,aAAa,+CAA+C;AAC5D,YAAY,gEAAgE;AAC5E,YAAY,mDAAmD;AAC/D,cAAc,uDAAuD;AACrE,UAAU,+CAA+C;AACzD,aAAa,+BAA+B;AAC5C,iBAAiB,mCAAmC;AACpD,QAAQ,2CAA2C;AACnD,YAAY,8BAA8B;AAC1C,cAAc,gDAAgD;AAC9D,aAAa,uEAAuE;AACpF,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,WAAW,iDAAiD;AAC5D,QAAQ,oEAAoE;AAC5E,QAAQ,+DAA+D;AACvE,QAAQ,oEAAoE;AAC5E,QAAQ,kEAAkE;AAC1E,IAAI,IAAI,yBAAyB,uBAAuB;AACxD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,6CAA6C;AACrD,QAAQ,gDAAgD;AACxD,QAAQ,kDAAkD;AAC1D,SAAS,iDAAiD;AAC1D,QAAQ,mDAAmD;AAC3D,SAAS,6CAA6C;AACtD,WAAW,8BAA8B;AACzC,YAAY,gDAAgD;AAC5D,YAAY,+BAA+B;AAC3C,eAAe,kCAAkC;AACjD,WAAW,8BAA8B;AACzC,cAAc,iCAAiC;AAC/C,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,4CAA4C;AACpD,QAAQ,6CAA6C;AACrD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,gDAAgD;AACxD,QAAQ,6CAA6C;AACrD,QAAQ,4CAA4C;AACpD,QAAQ,6CAA6C;AACrD,QAAQ,4CAA4C;AACpD,QAAQ,gDAAgD;AACxD,IAAI,IAAI,yBAAyB,yBAAyB;AAC1D,QAAQ,gDAAgD;AACxD,IAAI,IAAI,yBAAyB,0BAA0B;AAC3D,QAAQ;AACR,E;;;;;;;;;;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mBAAmB;AAC1B,OAAO,2BAA2B;;AAElC;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,OAAO;AACpB,aAAa,qCAAqC;AAClD,aAAa,6CAA6C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAmD;AAClE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;;AAEpB;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,eAAe,IAAI,IAAI,sCAAsC;;AAE7D;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa,IAAI,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA,aAAa,+BAA+B;AAC5C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA,gDAAgD,gCAAgC;AAChF;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,uGAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU,GAAG,WAAW;AACnD;AACA;AACA,4BAA4B,UAAU,GAAG,WAAW,GAAG,SAAS;AAChE;AACA;AACA;AACA,6BAA6B,UAAU,GAAG,WAAW;AACrD;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,6BAA6B,UAAU,QAAQ,sBAAsB;AACrE;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU,QAAQ,SAAS;AAC9C;AACA,6BAA6B,UAAU,QAAQ,sBAAsB;AACrE;AACA,OAAO;AACP;;AAEA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB,eAAe;AACf;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,aAAa,QAAQ,uEAAuE,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjSA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA,oB","file":"background.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","window.ws = WebSocket;\nconst Puppeteer = require('./lib/Puppeteer');\n\n(async () => {\n  let tabId = await new Promise((resolve, reject) => {\n    chrome.tabs.query({ active: true }, tabs => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve(tabs[0].id);\n    });\n  });\n  let browser = await Puppeteer.connect({ tabId });\n  const page = await browser.newPage();\n  await page.goto('https://example.com');\n  await page.screenshot({ path: 'example.png' });\n\n  await browser.close();\n})();\n","/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter = require('events');\n\nclass Extension extends EventEmitter {\n  static create(tabId) {\n    return new Promise((resolve, reject) => {\n      let debuggee = { tabId };\n      chrome.debugger.attach(debuggee, '1.3', () => {\n        if (chrome.runtime.lastError) {\n          if (\n            chrome.runtime.lastError.message.match(\n              /Another debugger is already attached/\n            )\n          ) {\n            return resolve(new Extension(debuggee));\n          }\n          return reject(chrome.runtime.lastError);\n        }\n        resolve(new Extension(debuggee));\n      });\n    });\n  }\n\n  /**\n   * @param debuggee\n   */\n  constructor(debuggee) {\n    super();\n    this._debuggee = debuggee;\n    this._sessionId = 0;\n\n    this._targetInfo = [];\n\n    chrome.debugger.onEvent.addListener((source, method, params) => {\n      console.log('onEvent', source, method, params);\n      if (this._debuggee.tabId !== source.tabId) {\n        return;\n      }\n      this.emit('message', JSON.stringify({ method, params }));\n    });\n    chrome.debugger.onDetach.addListener((source, reason) => {\n      console.log('onDetach', source, reason);\n      if (this._debuggee.tabId !== source.tabId) {\n        return;\n      }\n      this.emit('close');\n    });\n  }\n\n  /**\n   * @param {string} message\n   */\n  async send(message) {\n    let { id, method, params } = JSON.parse(message);\n    console.log('>>>', message);\n    if (method === 'Target.setDiscoverTargets') {\n      console.log('skip');\n        await this._setTimeout();\n      await this._checkTargets();\n      let result = { id, result: {} };\n        console.log('<<<', result);\n      this.emit('message', JSON.stringify(result));\n      return;\n    }\n    if (method === 'Target.attachToTarget') {\n      console.log('skip');\n        await this._setTimeout();\n      await this._checkTargets();\n        let result = {\n            id,\n            result: {\n                sessionId: `ExtensionSessionId${++this._sessionId}`,\n            },\n        };\n        console.log('<<<', result);\n      this.emit(\n        'message',\n        JSON.stringify(result)\n      );\n      return;\n    }\n    if (method === 'Target.sendMessageToTarget') {\n      console.log('skip');\n      await this._setTimeout();\n        let message = JSON.parse(params.message);\n        console.log('>>>', message);\n        let result = await this._sendCommand(\n            message.id,\n            message.method,\n            message.params\n        );\n        await this._setTimeout();\n        console.log('<<<', JSON.stringify(result));\n        message.result = result;\n        params.message = JSON.stringify(message);\n        this.emit(\n            'message',\n            JSON.stringify({\n                method: 'Target.receivedMessageFromTarget',\n                params,\n            })\n        );\n      return;\n    }\n    this._send(id, method, params);\n  }\n\n  close() {\n    chrome.debugger.detach(this._debuggee, () => {\n      if (chrome.runtime.lastError) {\n        throw chrome.runtime.lastError;\n      }\n    });\n  }\n\n  _setTimeout(time = 0) {\n      return new Promise((resolve) => setTimeout(resolve, time));\n  }\n\n  async _send(id, method, params) {\n    let result = await this._sendCommand(id, method, params);\n    if (method === 'Target.createTarget') {\n      await this._checkTargets();\n    }\n    console.log('<<<', JSON.stringify({ id, result }));\n    this.emit('message', JSON.stringify({ id, result }));\n  }\n\n  _sendCommand(id, method, params) {\n    return new Promise((resolve, reject) => {\n      chrome.debugger.sendCommand(this._debuggee, method, params, result => {\n        if (chrome.runtime.lastError) {\n          return reject(chrome.runtime.lastError);\n        }\n        resolve(result);\n      });\n    });\n  }\n\n  _checkTargets() {\n    return new Promise(resolve => {\n      let emit = method => targetInfo => {\n        this.emit(\n          'message',\n          JSON.stringify({\n            method,\n            params: {\n              targetInfo: {\n                ...targetInfo,\n                targetId: targetInfo.id,\n              },\n            },\n          })\n        );\n      };\n      let types = {\n        created: emit('Target.targetCreated'),\n        deleted: emit('Target.targetDestroyed'),\n        changed: emit('Target.targetInfoChanged'),\n      };\n      chrome.debugger.getTargets(targetInfoList => {\n        let reducedInfo = this._targetInfo.reduce((base, cur) => {\n          let filtered = targetInfoList.filter(diff => cur.id !== diff.id);\n          if (filtered.length === targetInfoList.length) {\n            types.deleted(cur);\n          } else {\n            base.push(cur);\n            types.changed(cur);\n          }\n          targetInfoList = filtered;\n          return base;\n        }, []);\n        targetInfoList.forEach(info => types.created(info));\n        this._targetInfo = reducedInfo.concat(targetInfoList);\n        resolve();\n      });\n    });\n  }\n}\n\nmodule.exports = Extension;\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst { Connection } = require('../node_modules/puppeteer-core/lib/Connection');\nconst Extension = require('./Extension');\nconst { Browser } = require('../node_modules/puppeteer-core/lib/Browser');\nconst { debugError } = require('../node_modules/puppeteer-core/lib/helper');\n\nclass Launcher {\n  /**\n   * @param {!(BrowserOptions & {browserWSEndpoint: string})=} options\n   * @return {!Promise<!Browser>}\n   */\n  static async connect(options) {\n    const {\n      tabId = null,\n      ignoreHTTPSErrors = false,\n      defaultViewport = { width: 800, height: 600 },\n      slowMo = 0,\n    } = options;\n    let extension = await Extension.create(tabId);\n    const connection = new Connection('', extension, slowMo);\n    const { browserContextIds } = await connection.send(\n      'Target.getBrowserContexts'\n    );\n    return Browser.create(\n      connection,\n      browserContextIds,\n      ignoreHTTPSErrors,\n      defaultViewport,\n      null,\n      () => connection.send('Browser.close').catch(debugError)\n    );\n  }\n}\n\nmodule.exports = Launcher;\n","const { helper } = require('../node_modules/puppeteer-core/lib/helper');\nconst Launcher = require('./Launcher');\n\nmodule.exports = class {\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<!Puppeteer.Browser>}\n   */\n  static launch(options) {\n    return Launcher.launch(options);\n  }\n\n  /**\n   * @param {{browserWSEndpoint: string, ignoreHTTPSErrors: boolean}} options\n   * @return {!Promise<!Puppeteer.Browser>}\n   */\n  static connect(options) {\n    return Launcher.connect(options);\n  }\n\n  /**\n   * @return {string}\n   */\n  static executablePath() {\n    return Launcher.executablePath();\n  }\n\n  /**\n   * @return {!Array<string>}\n   */\n  static defaultArgs(options) {\n    return Launcher.defaultArgs(options);\n  }\n};\n\nhelper.tracePublicAPI(module.exports, 'Puppeteer');\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict';\n\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (var i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n}\n\n/**\n * Define mimetype -> xtension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\nMime.prototype.define = function(typeMap, force) {\n  for (var type in typeMap) {\n    var extensions = typeMap[type];\n    for (var i = 0; i < extensions.length; i++) {\n      var ext = extensions[i];\n\n      // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n      if (ext[0] == '*') {\n        continue;\n      }\n\n      if (!force && (ext in this._types)) {\n        throw new Error(\n          'Attempt to change mapping for \"' + ext +\n          '\" extension from \"' + this._types[ext] + '\" to \"' + type +\n          '\". Pass `force=true` to allow this, otherwise remove \"' + ext +\n          '\" from the list of extensions for \"' + type + '\".'\n        );\n      }\n\n      this._types[ext] = type;\n    }\n\n    // Use first extension as default\n    if (force || !this._extensions[type]) {\n      var ext = extensions[0];\n      this._extensions[type] = (ext[0] != '*') ? ext : ext.substr(1)\n    }\n  }\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.getType = function(path) {\n  path = String(path);\n  var last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  var ext = last.replace(/^.*\\./, '').toLowerCase();\n\n  var hasPath = last.length < path.length;\n  var hasDot = ext.length < last.length - 1;\n\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.getExtension = function(type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;\n","'use strict';\n\nvar Mime = require('./Mime');\nmodule.exports = new Mime(require('./types/standard'), require('./types/other'));\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { helper, assert } = require('./helper');\nconst {Target} = require('./Target');\nconst EventEmitter = require('events');\nconst {TaskQueue} = require('./TaskQueue');\n\nclass Browser extends EventEmitter {\n  /**\n   * @param {!Puppeteer.Connection} connection\n   * @param {!Array<string>} contextIds\n   * @param {boolean} ignoreHTTPSErrors\n   * @param {?Puppeteer.Viewport} defaultViewport\n   * @param {?Puppeteer.ChildProcess} process\n   * @param {(function():Promise)=} closeCallback\n   */\n  constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n    super();\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._defaultViewport = defaultViewport;\n    this._process = process;\n    this._screenshotTaskQueue = new TaskQueue();\n    this._connection = connection;\n    this._closeCallback = closeCallback || new Function();\n\n    this._defaultContext = new BrowserContext(this, null);\n    /** @type {Map<string, BrowserContext>} */\n    this._contexts = new Map();\n    for (const contextId of contextIds)\n      this._contexts.set(contextId, new BrowserContext(this, contextId));\n\n    /** @type {Map<string, Target>} */\n    this._targets = new Map();\n    this._connection.setClosedCallback(() => {\n      this.emit(Browser.Events.Disconnected);\n    });\n    this._connection.on('Target.targetCreated', this._targetCreated.bind(this));\n    this._connection.on('Target.targetDestroyed', this._targetDestroyed.bind(this));\n    this._connection.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));\n  }\n\n  /**\n   * @return {?Puppeteer.ChildProcess}\n   */\n  process() {\n    return this._process;\n  }\n\n  /**\n   * @return {!Promise<!BrowserContext>}\n   */\n  async createIncognitoBrowserContext() {\n    const {browserContextId} = await this._connection.send('Target.createBrowserContext');\n    const context = new BrowserContext(this, browserContextId);\n    this._contexts.set(browserContextId, context);\n    return context;\n  }\n\n  /**\n   * @return {!Array<!BrowserContext>}\n   */\n  browserContexts() {\n    return [this._defaultContext, ...Array.from(this._contexts.values())];\n  }\n\n  /**\n   * @param {?string} contextId\n   */\n  async _disposeContext(contextId) {\n    await this._connection.send('Target.disposeBrowserContext', {browserContextId: contextId || undefined});\n    this._contexts.delete(contextId);\n  }\n\n  /**\n   * @param {!Puppeteer.Connection} connection\n   * @param {!Array<string>} contextIds\n   * @param {boolean} ignoreHTTPSErrors\n   * @param {?Puppeteer.Viewport} defaultViewport\n   * @param {?Puppeteer.ChildProcess} process\n   * @param {function()=} closeCallback\n   */\n  static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n    const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);\n    await connection.send('Target.setDiscoverTargets', {discover: true});\n    return browser;\n  }\n\n  /**\n   * @param {!Protocol.Target.targetCreatedPayload} event\n   */\n  async _targetCreated(event) {\n    const targetInfo = event.targetInfo;\n    const {browserContextId} = targetInfo;\n    const context = (browserContextId && this._contexts.has(browserContextId)) ? this._contexts.get(browserContextId) : this._defaultContext;\n\n    const target = new Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue);\n    assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');\n    this._targets.set(event.targetInfo.targetId, target);\n\n    if (await target._initializedPromise) {\n      this.emit(Browser.Events.TargetCreated, target);\n      context.emit(BrowserContext.Events.TargetCreated, target);\n    }\n  }\n\n  /**\n   * @param {{targetId: string}} event\n   */\n  async _targetDestroyed(event) {\n    const target = this._targets.get(event.targetId);\n    target._initializedCallback(false);\n    this._targets.delete(event.targetId);\n    target._closedCallback();\n    if (await target._initializedPromise) {\n      this.emit(Browser.Events.TargetDestroyed, target);\n      target.browserContext().emit(BrowserContext.Events.TargetDestroyed, target);\n    }\n  }\n\n  /**\n   * @param {!Protocol.Target.targetInfoChangedPayload} event\n   */\n  _targetInfoChanged(event) {\n    const target = this._targets.get(event.targetInfo.targetId);\n    assert(target, 'target should exist before targetInfoChanged');\n    const previousURL = target.url();\n    const wasInitialized = target._isInitialized;\n    target._targetInfoChanged(event.targetInfo);\n    if (wasInitialized && previousURL !== target.url()) {\n      this.emit(Browser.Events.TargetChanged, target);\n      target.browserContext().emit(BrowserContext.Events.TargetChanged, target);\n    }\n  }\n\n  /**\n   * @return {string}\n   */\n  wsEndpoint() {\n    return this._connection.url();\n  }\n\n  /**\n   * @return {!Promise<!Puppeteer.Page>}\n   */\n  async newPage() {\n    return this._defaultContext.newPage();\n  }\n\n  /**\n   * @param {string} contextId\n   * @return {!Promise<!Puppeteer.Page>}\n   */\n  async _createPageInContext(contextId) {\n    const {targetId} = await this._connection.send('Target.createTarget', {url: 'about:blank', browserContextId: contextId || undefined});\n    const target = await this._targets.get(targetId);\n    assert(await target._initializedPromise, 'Failed to create target for page');\n    const page = await target.page();\n    return page;\n  }\n\n  /**\n   * @return {!Array<!Target>}\n   */\n  targets() {\n    return Array.from(this._targets.values()).filter(target => target._isInitialized);\n  }\n\n  /**\n   * @return {!Promise<!Array<!Puppeteer.Page>>}\n   */\n  async pages() {\n    const contextPages = await Promise.all(this.browserContexts().map(context => context.pages()));\n    // Flatten array.\n    return contextPages.reduce((acc, x) => acc.concat(x), []);\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async version() {\n    const version = await this._getVersion();\n    return version.product;\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async userAgent() {\n    const version = await this._getVersion();\n    return version.userAgent;\n  }\n\n  async close() {\n    await this._closeCallback.call(null);\n    this.disconnect();\n  }\n\n  disconnect() {\n    this._connection.dispose();\n  }\n\n  /**\n   * @return {!Promise<!Object>}\n   */\n  _getVersion() {\n    return this._connection.send('Browser.getVersion');\n  }\n}\n\n/** @enum {string} */\nBrowser.Events = {\n  TargetCreated: 'targetcreated',\n  TargetDestroyed: 'targetdestroyed',\n  TargetChanged: 'targetchanged',\n  Disconnected: 'disconnected'\n};\n\nclass BrowserContext extends EventEmitter {\n  /**\n   * @param {!Browser} browser\n   * @param {?string} contextId\n   */\n  constructor(browser, contextId) {\n    super();\n    this._browser = browser;\n    this._id = contextId;\n  }\n\n  /**\n   * @return {!Array<!Target>} target\n   */\n  targets() {\n    return this._browser.targets().filter(target => target.browserContext() === this);\n  }\n\n  /**\n   * @return {!Promise<!Array<!Puppeteer.Page>>}\n   */\n  async pages() {\n    const pages = await Promise.all(\n        this.targets()\n            .filter(target => target.type() === 'page')\n            .map(target => target.page())\n    );\n    return pages.filter(page => !!page);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isIncognito() {\n    return !!this._id;\n  }\n\n  /**\n   * @return {!Promise<!Puppeteer.Page>}\n   */\n  newPage() {\n    return this._browser._createPageInContext(this._id);\n  }\n\n  /**\n   * @return {!Browser}\n   */\n  browser() {\n    return this._browser;\n  }\n\n  async close() {\n    assert(this._id, 'Non-incognito profiles cannot be closed!');\n    await this._browser._disposeContext(this._id);\n  }\n}\n\n/** @enum {string} */\nBrowserContext.Events = {\n  TargetCreated: 'targetcreated',\n  TargetDestroyed: 'targetdestroyed',\n  TargetChanged: 'targetchanged',\n};\n\nhelper.tracePublicAPI(BrowserContext);\nhelper.tracePublicAPI(Browser);\n\nmodule.exports = {Browser, BrowserContext};\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {helper, assert} = require('./helper');\nconst debugProtocol = require('debug')('puppeteer:protocol');\nconst debugSession = require('debug')('puppeteer:session');\n\nconst EventEmitter = require('events');\nconst WebSocket = require('ws');\nconst Pipe = require('./Pipe');\n\nclass Connection extends EventEmitter {\n  /**\n   * @param {string} url\n   * @param {number=} delay\n   * @return {!Promise<!Connection>}\n   */\n  static async createForWebSocket(url, delay = 0) {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket(url, { perMessageDeflate: false });\n      ws.on('open', () => resolve(new Connection(url, ws, delay)));\n      ws.on('error', reject);\n    });\n  }\n\n  /**\n   * @param {!NodeJS.WritableStream} pipeWrite\n   * @param {!NodeJS.ReadableStream} pipeRead\n   * @param {number=} delay\n   * @return {!Connection}\n   */\n  static createForPipe(pipeWrite, pipeRead, delay = 0) {\n    return new Connection('', new Pipe(pipeWrite, pipeRead), delay);\n  }\n\n  /**\n   * @param {string} url\n   * @param {!Puppeteer.ConnectionTransport} transport\n   * @param {number=} delay\n   */\n  constructor(url, transport, delay = 0) {\n    super();\n    this._url = url;\n    this._lastId = 0;\n    /** @type {!Map<number, {resolve: function, reject: function, error: !Error, method: string}>}*/\n    this._callbacks = new Map();\n    this._delay = delay;\n\n    this._transport = transport;\n    this._transport.on('message', this._onMessage.bind(this));\n    this._transport.on('close', this._onClose.bind(this));\n    /** @type {!Map<string, !CDPSession>}*/\n    this._sessions = new Map();\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @param {string} method\n   * @param {!Object=} params\n   * @return {!Promise<?Object>}\n   */\n  send(method, params = {}) {\n    const id = ++this._lastId;\n    const message = JSON.stringify({id, method, params});\n    debugProtocol('SEND ► ' + message);\n    this._transport.send(message);\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {resolve, reject, error: new Error(), method});\n    });\n  }\n\n  /**\n   * @param {function()} callback\n   */\n  setClosedCallback(callback) {\n    this._closeCallback = callback;\n  }\n\n  /**\n   * @param {string} message\n   */\n  async _onMessage(message) {\n    if (this._delay)\n      await new Promise(f => setTimeout(f, this._delay));\n    debugProtocol('◀ RECV ' + message);\n    const object = JSON.parse(message);\n    if (object.id) {\n      const callback = this._callbacks.get(object.id);\n      // Callbacks could be all rejected if someone has called `.dispose()`.\n      if (callback) {\n        this._callbacks.delete(object.id);\n        if (object.error)\n          callback.reject(createProtocolError(callback.error, callback.method, object));\n        else\n          callback.resolve(object.result);\n      }\n    } else {\n      if (object.method === 'Target.receivedMessageFromTarget') {\n        const session = this._sessions.get(object.params.sessionId);\n        if (session)\n          session._onMessage(object.params.message);\n      } else if (object.method === 'Target.detachedFromTarget') {\n        const session = this._sessions.get(object.params.sessionId);\n        if (session)\n          session._onClosed();\n        this._sessions.delete(object.params.sessionId);\n      } else {\n        this.emit(object.method, object.params);\n      }\n    }\n  }\n\n  _onClose() {\n    if (this._closeCallback) {\n      this._closeCallback();\n      this._closeCallback = null;\n    }\n    this._transport.removeAllListeners();\n    // If transport throws any error at this point of time, we don't care and should swallow it.\n    this._transport.on('error', () => {});\n    for (const callback of this._callbacks.values())\n      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n    this._callbacks.clear();\n    for (const session of this._sessions.values())\n      session._onClosed();\n    this._sessions.clear();\n  }\n\n  dispose() {\n    this._onClose();\n    this._transport.close();\n  }\n\n  /**\n   * @param {Protocol.Target.TargetInfo} targetInfo\n   * @return {!Promise<!CDPSession>}\n   */\n  async createSession(targetInfo) {\n    const {sessionId} = await this.send('Target.attachToTarget', {targetId: targetInfo.targetId});\n    const session = new CDPSession(this, targetInfo.type, sessionId);\n    this._sessions.set(sessionId, session);\n    return session;\n  }\n}\n\nclass CDPSession extends EventEmitter {\n  /**\n   * @param {!Connection|!CDPSession} connection\n   * @param {string} targetType\n   * @param {string} sessionId\n   */\n  constructor(connection, targetType, sessionId) {\n    super();\n    this._lastId = 0;\n    /** @type {!Map<number, {resolve: function, reject: function, error: !Error, method: string}>}*/\n    this._callbacks = new Map();\n    this._connection = connection;\n    this._targetType = targetType;\n    this._sessionId = sessionId;\n    /** @type {!Map<string, !CDPSession>}*/\n    this._sessions = new Map();\n  }\n\n  /**\n   * @param {string} method\n   * @param {!Object=} params\n   * @return {!Promise<?Object>}\n   */\n  send(method, params = {}) {\n    if (!this._connection)\n      return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));\n    const id = ++this._lastId;\n    const message = JSON.stringify({id, method, params});\n    debugSession('SEND ► ' + message);\n    this._connection.send('Target.sendMessageToTarget', {sessionId: this._sessionId, message}).catch(e => {\n      // The response from target might have been already dispatched.\n      if (!this._callbacks.has(id))\n        return;\n      const callback = this._callbacks.get(id);\n      this._callbacks.delete(id);\n      callback.reject(rewriteError(callback.error, e && e.message));\n    });\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {resolve, reject, error: new Error(), method});\n    });\n  }\n\n  /**\n   * @param {string} message\n   */\n  _onMessage(message) {\n    debugSession('◀ RECV ' + message);\n    const object = JSON.parse(message);\n    if (object.id && this._callbacks.has(object.id)) {\n      const callback = this._callbacks.get(object.id);\n      this._callbacks.delete(object.id);\n      if (object.error)\n        callback.reject(createProtocolError(callback.error, callback.method, object));\n      else\n        callback.resolve(object.result);\n    } else {\n      if (object.method === 'Target.receivedMessageFromTarget') {\n        const session = this._sessions.get(object.params.sessionId);\n        if (session)\n          session._onMessage(object.params.message);\n      } else if (object.method === 'Target.detachedFromTarget') {\n        const session = this._sessions.get(object.params.sessionId);\n        if (session) {\n          session._onClosed();\n          this._sessions.delete(object.params.sessionId);\n        }\n      }\n      assert(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n\n  async detach() {\n    await this._connection.send('Target.detachFromTarget',  {sessionId: this._sessionId});\n  }\n\n  _onClosed() {\n    for (const callback of this._callbacks.values())\n      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n    this._callbacks.clear();\n    this._connection = null;\n  }\n\n  /**\n   * @param {string} targetType\n   * @param {string} sessionId\n   */\n  _createSession(targetType, sessionId) {\n    const session = new CDPSession(this, targetType, sessionId);\n    this._sessions.set(sessionId, session);\n    return session;\n  }\n}\nhelper.tracePublicAPI(CDPSession);\n\n/**\n * @param {!Error} error\n * @param {string} method\n * @param {{error: {message: string, data: any}}} object\n * @return {!Error}\n */\nfunction createProtocolError(error, method, object) {\n  let message = `Protocol error (${method}): ${object.error.message}`;\n  if ('data' in object.error)\n    message += ` ${object.error.data}`;\n  if (object.error.message)\n    return rewriteError(error, message);\n}\n\n/**\n * @param {!Error} error\n * @param {string} message\n * @return {!Error}\n */\nfunction rewriteError(error, message) {\n  error.message = message;\n  return error;\n}\n\nmodule.exports = {Connection, CDPSession};\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {helper, debugError, assert} = require('./helper');\n\nconst {EVALUATION_SCRIPT_URL} = require('./ExecutionContext');\n\n/**\n * @typedef {Object} CoverageEntry\n * @property {string} url\n * @property {string} text\n * @property {!Array<!{start: number, end: number}>} ranges\n */\n\nclass Coverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._jsCoverage = new JSCoverage(client);\n    this._cssCoverage = new CSSCoverage(client);\n  }\n\n  /**\n   * @param {!Object} options\n   */\n  async startJSCoverage(options) {\n    return await this._jsCoverage.start(options);\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stopJSCoverage() {\n    return await this._jsCoverage.stop();\n  }\n\n  /**\n   * @param {!Object} options\n   */\n  async startCSSCoverage(options) {\n    return await this._cssCoverage.start(options);\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stopCSSCoverage() {\n    return await this._cssCoverage.stop();\n  }\n}\n\nmodule.exports = {Coverage};\nhelper.tracePublicAPI(Coverage);\n\nclass JSCoverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._enabled = false;\n    this._scriptURLs = new Map();\n    this._scriptSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n\n  /**\n   * @param {!Object} options\n   */\n  async start(options = {}) {\n    assert(!this._enabled, 'JSCoverage is already enabled');\n    this._resetOnNavigation = options.resetOnNavigation === undefined ? true : !!options.resetOnNavigation;\n    this._reportAnonymousScripts = !!options.reportAnonymousScripts;\n    this._enabled = true;\n    this._scriptURLs.clear();\n    this._scriptSources.clear();\n    this._eventListeners = [\n      helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),\n      helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n    ];\n    await Promise.all([\n      this._client.send('Profiler.enable'),\n      this._client.send('Profiler.startPreciseCoverage', {callCount: false, detailed: true}),\n      this._client.send('Debugger.enable'),\n      this._client.send('Debugger.setSkipAllPauses', {skip: true})\n    ]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation)\n      return;\n    this._scriptURLs.clear();\n    this._scriptSources.clear();\n  }\n\n  /**\n   * @param {!Protocol.Debugger.scriptParsedPayload} event\n   */\n  async _onScriptParsed(event) {\n    // Ignore puppeteer-injected scripts\n    if (event.url === EVALUATION_SCRIPT_URL)\n      return;\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !this._reportAnonymousScripts)\n      return;\n    try {\n      const response = await this._client.send('Debugger.getScriptSource', {scriptId: event.scriptId});\n      this._scriptURLs.set(event.scriptId, event.url);\n      this._scriptSources.set(event.scriptId, response.scriptSource);\n    } catch (e) {\n      // This might happen if the page has already navigated away.\n      debugError(e);\n    }\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stop() {\n    assert(this._enabled, 'JSCoverage is not enabled');\n    this._enabled = false;\n    const [profileResponse] = await Promise.all([\n      this._client.send('Profiler.takePreciseCoverage'),\n      this._client.send('Profiler.stopPreciseCoverage'),\n      this._client.send('Profiler.disable'),\n      this._client.send('Debugger.disable'),\n    ]);\n    helper.removeEventListeners(this._eventListeners);\n\n    const coverage = [];\n    for (const entry of profileResponse.result) {\n      let url = this._scriptURLs.get(entry.scriptId);\n      if (!url && this._reportAnonymousScripts)\n        url = 'debugger://VM' + entry.scriptId;\n      const text = this._scriptSources.get(entry.scriptId);\n      if (text === undefined || url === undefined)\n        continue;\n      const flattenRanges = [];\n      for (const func of entry.functions)\n        flattenRanges.push(...func.ranges);\n      const ranges = convertToDisjointRanges(flattenRanges);\n      coverage.push({url, ranges, text});\n    }\n    return coverage;\n  }\n}\n\nclass CSSCoverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._enabled = false;\n    this._stylesheetURLs = new Map();\n    this._stylesheetSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n\n  /**\n   * @param {!Object} options\n   */\n  async start(options = {}) {\n    assert(!this._enabled, 'CSSCoverage is already enabled');\n    this._resetOnNavigation = options.resetOnNavigation === undefined ? true : !!options.resetOnNavigation;\n    this._enabled = true;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n    this._eventListeners = [\n      helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),\n      helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n    ];\n    await Promise.all([\n      this._client.send('DOM.enable'),\n      this._client.send('CSS.enable'),\n      this._client.send('CSS.startRuleUsageTracking'),\n    ]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation)\n      return;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n  }\n\n  /**\n   * @param {!Protocol.CSS.styleSheetAddedPayload} event\n   */\n  async _onStyleSheet(event) {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL)\n      return;\n    try {\n      const response = await this._client.send('CSS.getStyleSheetText', {styleSheetId: header.styleSheetId});\n      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n      this._stylesheetSources.set(header.styleSheetId, response.text);\n    } catch (e) {\n      // This might happen if the page has already navigated away.\n      debugError(e);\n    }\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stop() {\n    assert(this._enabled, 'CSSCoverage is not enabled');\n    this._enabled = false;\n    const [ruleTrackingResponse] = await Promise.all([\n      this._client.send('CSS.stopRuleUsageTracking'),\n      this._client.send('CSS.disable'),\n      this._client.send('DOM.disable'),\n    ]);\n    helper.removeEventListeners(this._eventListeners);\n\n    // aggregate by styleSheetId\n    const styleSheetIdToCoverage = new Map();\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0,\n      });\n    }\n\n    const coverage = [];\n    for (const styleSheetId of this._stylesheetURLs.keys()) {\n      const url = this._stylesheetURLs.get(styleSheetId);\n      const text = this._stylesheetSources.get(styleSheetId);\n      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n      coverage.push({url, ranges, text});\n    }\n\n    return coverage;\n  }\n}\n\n/**\n * @param {!Array<!{startOffset:number, endOffset:number, count:number}>} nestedRanges\n * @return {!Array<!{start:number, end:number}>}\n */\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n  for (const range of nestedRanges) {\n    points.push({ offset: range.startOffset, type: 0, range });\n    points.push({ offset: range.endOffset, type: 1, range });\n  }\n  // Sort points to form a valid parenthesis sequence.\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset)\n      return a.offset - b.offset;\n    // All \"end\" points should go before \"start\" points.\n    if (a.type !== b.type)\n      return b.type - a.type;\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset;\n    // For two \"start\" points, the one with longer range goes first.\n    if (a.type === 0)\n      return bLength - aLength;\n    // For two \"end\" points, the one with shorter range goes first.\n    return aLength - bLength;\n  });\n\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0;\n  // Run scanning line to intersect all ranges.\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results.length ? results[results.length - 1] : null;\n      if (lastResult && lastResult.end === lastOffset)\n        lastResult.end = point.offset;\n      else\n        results.push({start: lastOffset, end: point.offset});\n    }\n    lastOffset = point.offset;\n    if (point.type === 0)\n      hitCountStack.push(point.range.count);\n    else\n      hitCountStack.pop();\n  }\n  // Filter out empty ranges.\n  return results.filter(range => range.end - range.start > 1);\n}\n\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {helper, assert} = require('./helper');\n\nclass Dialog {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {string} type\n   * @param {string} message\n   * @param {(string|undefined)} defaultValue\n   */\n  constructor(client, type, message, defaultValue = '') {\n    this._client = client;\n    this._type = type;\n    this._message = message;\n    this._handled = false;\n    this._defaultValue = defaultValue;\n  }\n\n  /**\n   * @return {string}\n   */\n  type() {\n    return this._type;\n  }\n\n  /**\n   * @return {string}\n   */\n  message() {\n    return this._message;\n  }\n\n  /**\n   * @return {string}\n   */\n  defaultValue() {\n    return this._defaultValue;\n  }\n\n  /**\n   * @param {string=} promptText\n   */\n  async accept(promptText) {\n    assert(!this._handled, 'Cannot accept dialog which is already handled!');\n    this._handled = true;\n    await this._client.send('Page.handleJavaScriptDialog', {\n      accept: true,\n      promptText: promptText\n    });\n  }\n\n  async dismiss() {\n    assert(!this._handled, 'Cannot dismiss dialog which is already handled!');\n    this._handled = true;\n    await this._client.send('Page.handleJavaScriptDialog', {\n      accept: false\n    });\n  }\n}\n\nDialog.Type = {\n  Alert: 'alert',\n  BeforeUnload: 'beforeunload',\n  Confirm: 'confirm',\n  Prompt: 'prompt'\n};\n\nmodule.exports = {Dialog};\nhelper.tracePublicAPI(Dialog);\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst path = require('path');\nconst {JSHandle} = require('./ExecutionContext');\nconst {helper, assert, debugError} = require('./helper');\n\nclass ElementHandle extends JSHandle {\n  /**\n   * @param {!Puppeteer.ExecutionContext} context\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   * @param {!Puppeteer.Page} page\n   * @param {!Puppeteer.FrameManager} frameManager\n   */\n  constructor(context, client, remoteObject, page, frameManager) {\n    super(context, client, remoteObject);\n    this._client = client;\n    this._remoteObject = remoteObject;\n    this._page = page;\n    this._frameManager = frameManager;\n    this._disposed = false;\n  }\n\n  /**\n   * @override\n   * @return {?ElementHandle}\n   */\n  asElement() {\n    return this;\n  }\n\n  /**\n   * @return {!Promise<?Puppeteer.Frame>}\n   */\n  async contentFrame() {\n    const nodeInfo = await this._client.send('DOM.describeNode', {\n      objectId: this._remoteObject.objectId\n    });\n    if (typeof nodeInfo.node.frameId !== 'string')\n      return null;\n    return this._frameManager.frame(nodeInfo.node.frameId);\n  }\n\n  async _scrollIntoViewIfNeeded() {\n    const error = await this.executionContext().evaluate(async(element, pageJavascriptEnabled) => {\n      if (!element.isConnected)\n        return 'Node is detached from document';\n      if (element.nodeType !== Node.ELEMENT_NODE)\n        return 'Node is not of type HTMLElement';\n      // force-scroll if page's javascript is disabled.\n      if (!pageJavascriptEnabled) {\n        element.scrollIntoView({block: 'center', inline: 'center', behavior: 'instant'});\n        return false;\n      }\n      const visibleRatio = await new Promise(resolve => {\n        const observer = new IntersectionObserver(entries => {\n          resolve(entries[0].intersectionRatio);\n          observer.disconnect();\n        });\n        observer.observe(element);\n      });\n      if (visibleRatio !== 1.0)\n        element.scrollIntoView({block: 'center', inline: 'center', behavior: 'instant'});\n      return false;\n    }, this, this._page._javascriptEnabled);\n    if (error)\n      throw new Error(error);\n  }\n\n  /**\n   * @return {!Promise<!{x: number, y: number}>}\n   */\n  async _clickablePoint() {\n    const result = await this._client.send('DOM.getContentQuads', {\n      objectId: this._remoteObject.objectId\n    }).catch(debugError);\n    if (!result || !result.quads.length)\n      throw new Error('Node is either not visible or not an HTMLElement');\n    // Filter out quads that have too small area to click into.\n    const quads = result.quads.map(quad => this._fromProtocolQuad(quad)).filter(quad => computeQuadArea(quad) > 1);\n    if (!quads.length)\n      throw new Error('Node is either not visible or not an HTMLElement');\n    // Return the middle point of the first quad.\n    const quad = quads[0];\n    let x = 0;\n    let y = 0;\n    for (const point of quad) {\n      x += point.x;\n      y += point.y;\n    }\n    return {\n      x: x / 4,\n      y: y / 4\n    };\n  }\n\n  /**\n   * @return {!Promise<void|Protocol.DOM.getBoxModelReturnValue>}\n   */\n  _getBoxModel() {\n    return this._client.send('DOM.getBoxModel', {\n      objectId: this._remoteObject.objectId\n    }).catch(error => debugError(error));\n  }\n\n  /**\n   * @param {!Array<number>} quad\n   * @return {!Array<object>}\n   */\n  _fromProtocolQuad(quad) {\n    return [\n      {x: quad[0], y: quad[1]},\n      {x: quad[2], y: quad[3]},\n      {x: quad[4], y: quad[5]},\n      {x: quad[6], y: quad[7]}\n    ];\n  }\n\n  async hover() {\n    await this._scrollIntoViewIfNeeded();\n    const {x, y} = await this._clickablePoint();\n    await this._page.mouse.move(x, y);\n  }\n\n  /**\n   * @param {!Object=} options\n   */\n  async click(options = {}) {\n    await this._scrollIntoViewIfNeeded();\n    const {x, y} = await this._clickablePoint();\n    await this._page.mouse.click(x, y, options);\n  }\n\n  /**\n   * @param {!Array<string>} filePaths\n   * @return {!Promise}\n   */\n  async uploadFile(...filePaths) {\n    const files = filePaths.map(filePath => path.resolve(filePath));\n    const objectId = this._remoteObject.objectId;\n    return this._client.send('DOM.setFileInputFiles', { objectId, files });\n  }\n\n  async tap() {\n    await this._scrollIntoViewIfNeeded();\n    const {x, y} = await this._clickablePoint();\n    await this._page.touchscreen.tap(x, y);\n  }\n\n  async focus() {\n    await this.executionContext().evaluate(element => element.focus(), this);\n  }\n\n  /**\n   * @param {string} text\n   * @param {{delay: (number|undefined)}=} options\n   */\n  async type(text, options) {\n    await this.focus();\n    await this._page.keyboard.type(text, options);\n  }\n\n  /**\n   * @param {string} key\n   * @param {!Object=} options\n   */\n  async press(key, options) {\n    await this.focus();\n    await this._page.keyboard.press(key, options);\n  }\n\n  /**\n   * @return {!Promise<?{x: number, y: number, width: number, height: number}>}\n   */\n  async boundingBox() {\n    const result = await this._getBoxModel();\n\n    if (!result)\n      return null;\n\n    const quad = result.model.border;\n    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);\n    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);\n    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;\n    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;\n\n    return {x, y, width, height};\n  }\n\n  /**\n   * @return {!Promise<?object>}\n   */\n  async boxModel() {\n    const result = await this._getBoxModel();\n\n    if (!result)\n      return null;\n\n    const {content, padding, border, margin, width, height} = result.model;\n    return {\n      content: this._fromProtocolQuad(content),\n      padding: this._fromProtocolQuad(padding),\n      border: this._fromProtocolQuad(border),\n      margin: this._fromProtocolQuad(margin),\n      width,\n      height\n    };\n  }\n\n  /**\n   *\n   * @param {!Object=} options\n   * @returns {!Promise<Object>}\n   */\n  async screenshot(options = {}) {\n    let needsViewportReset = false;\n\n    let boundingBox = await this.boundingBox();\n    assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n\n    const viewport = this._page.viewport();\n\n    if (boundingBox.width > viewport.width || boundingBox.height > viewport.height) {\n      const newViewport = {\n        width: Math.max(viewport.width, Math.ceil(boundingBox.width)),\n        height: Math.max(viewport.height, Math.ceil(boundingBox.height)),\n      };\n      await this._page.setViewport(Object.assign({}, viewport, newViewport));\n\n      needsViewportReset = true;\n    }\n\n    await this._scrollIntoViewIfNeeded();\n\n    boundingBox = await this.boundingBox();\n    assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n\n    const { layoutViewport: { pageX, pageY } } = await this._client.send('Page.getLayoutMetrics');\n\n    const clip = Object.assign({}, boundingBox);\n    clip.x += pageX;\n    clip.y += pageY;\n\n    const imageData = await this._page.screenshot(Object.assign({}, {\n      clip\n    }, options));\n\n    if (needsViewportReset)\n      await this._page.setViewport(viewport);\n\n    return imageData;\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<?ElementHandle>}\n   */\n  async $(selector) {\n    const handle = await this.executionContext().evaluateHandle(\n        (element, selector) => element.querySelector(selector),\n        this, selector\n    );\n    const element = handle.asElement();\n    if (element)\n      return element;\n    await handle.dispose();\n    return null;\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<!Array<!ElementHandle>>}\n   */\n  async $$(selector) {\n    const arrayHandle = await this.executionContext().evaluateHandle(\n        (element, selector) => element.querySelectorAll(selector),\n        this, selector\n    );\n    const properties = await arrayHandle.getProperties();\n    await arrayHandle.dispose();\n    const result = [];\n    for (const property of properties.values()) {\n      const elementHandle = property.asElement();\n      if (elementHandle)\n        result.push(elementHandle);\n    }\n    return result;\n  }\n\n  /**\n   * @param {string} selector\n   * @param {Function|String} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $eval(selector, pageFunction, ...args) {\n    const elementHandle = await this.$(selector);\n    if (!elementHandle)\n      throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n    const result = await this.executionContext().evaluate(pageFunction, elementHandle, ...args);\n    await elementHandle.dispose();\n    return result;\n  }\n\n  /**\n   * @param {string} selector\n   * @param {Function|String} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $$eval(selector, pageFunction, ...args) {\n    const arrayHandle = await this.executionContext().evaluateHandle(\n        (element, selector) => Array.from(element.querySelectorAll(selector)),\n        this, selector\n    );\n\n    const result = await this.executionContext().evaluate(pageFunction, arrayHandle, ...args);\n    await arrayHandle.dispose();\n    return result;\n  }\n\n  /**\n   * @param {string} expression\n   * @return {!Promise<!Array<!ElementHandle>>}\n   */\n  async $x(expression) {\n    const arrayHandle = await this.executionContext().evaluateHandle(\n        (element, expression) => {\n          const document = element.ownerDocument || element;\n          const iterator = document.evaluate(expression, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n          const array = [];\n          let item;\n          while ((item = iterator.iterateNext()))\n            array.push(item);\n          return array;\n        },\n        this, expression\n    );\n    const properties = await arrayHandle.getProperties();\n    await arrayHandle.dispose();\n    const result = [];\n    for (const property of properties.values()) {\n      const elementHandle = property.asElement();\n      if (elementHandle)\n        result.push(elementHandle);\n    }\n    return result;\n  }\n\n  /**\n   * @returns {!Promise<boolean>}\n   */\n  isIntersectingViewport() {\n    return this.executionContext().evaluate(async element => {\n      const visibleRatio = await new Promise(resolve => {\n        const observer = new IntersectionObserver(entries => {\n          resolve(entries[0].intersectionRatio);\n          observer.disconnect();\n        });\n        observer.observe(element);\n      });\n      return visibleRatio > 0;\n    }, this);\n  }\n}\n\nfunction computeQuadArea(quad) {\n  // Compute sum of all directed areas of adjacent triangles\n  // https://en.wikipedia.org/wiki/Polygon#Simple_polygons\n  let area = 0;\n  for (let i = 0; i < quad.length; ++i) {\n    const p1 = quad[i];\n    const p2 = quad[(i + 1) % quad.length];\n    area += (p1.x * p2.y - p2.x * p1.y) / 2;\n  }\n  return area;\n}\n\nmodule.exports = {ElementHandle};\nhelper.tracePublicAPI(ElementHandle);\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass EmulationManager {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._emulatingMobile = false;\n    this._hasTouch = false;\n  }\n\n  /**\n   * @param {!Puppeteer.Viewport} viewport\n   * @return {Promise<boolean>}\n   */\n  async emulateViewport(viewport) {\n    const mobile = viewport.isMobile || false;\n    const width = viewport.width;\n    const height = viewport.height;\n    const deviceScaleFactor = viewport.deviceScaleFactor || 1;\n    /** @type {Protocol.Emulation.ScreenOrientation} */\n    const screenOrientation = viewport.isLandscape ? { angle: 90, type: 'landscapePrimary' } : { angle: 0, type: 'portraitPrimary' };\n    const hasTouch = viewport.hasTouch || false;\n\n    await Promise.all([\n      this._client.send('Emulation.setDeviceMetricsOverride', { mobile, width, height, deviceScaleFactor, screenOrientation }),\n      this._client.send('Emulation.setTouchEmulationEnabled', {\n        enabled: hasTouch\n      })\n    ]);\n\n    const reloadNeeded = this._emulatingMobile !== mobile || this._hasTouch !== hasTouch;\n    this._emulatingMobile = mobile;\n    this._hasTouch = hasTouch;\n    return reloadNeeded;\n  }\n}\n\nmodule.exports = {EmulationManager};\n","/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass TimeoutError extends CustomError {}\n\nmodule.exports = {\n  TimeoutError,\n};\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {helper, assert} = require('./helper');\n\nconst EVALUATION_SCRIPT_URL = '__puppeteer_evaluation_script__';\nconst SOURCE_URL_REGEX = /^[\\040\\t]*\\/\\/[@#] sourceURL=\\s*(\\S*?)\\s*$/m;\n\nclass ExecutionContext {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.ExecutionContextDescription} contextPayload\n   * @param {function(!Protocol.Runtime.RemoteObject):!JSHandle} objectHandleFactory\n   * @param {?Puppeteer.Frame} frame\n   */\n  constructor(client, contextPayload, objectHandleFactory, frame) {\n    this._client = client;\n    this._frame = frame;\n    this._contextId = contextPayload.id;\n    this._isDefault = contextPayload.auxData ? !!contextPayload.auxData['isDefault'] : false;\n    this._objectHandleFactory = objectHandleFactory;\n  }\n\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n  frame() {\n    return this._frame;\n  }\n\n  /**\n   * @param {Function|string} pageFunction\n   * @param {...*} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async evaluate(pageFunction, ...args) {\n    const handle = await this.evaluateHandle(pageFunction, ...args);\n    const result = await handle.jsonValue().catch(error => {\n      if (error.message.includes('Object reference chain is too long'))\n        return;\n      if (error.message.includes('Object couldn\\'t be returned by value'))\n        return;\n      throw error;\n    });\n    await handle.dispose();\n    return result;\n  }\n\n  /**\n   * @param {Function|string} pageFunction\n   * @param {...*} args\n   * @return {!Promise<!JSHandle>}\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    const suffix = `//# sourceURL=${EVALUATION_SCRIPT_URL}`;\n\n    if (helper.isString(pageFunction)) {\n      const contextId = this._contextId;\n      const expression = /** @type {string} */ (pageFunction);\n      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + '\\n' + suffix;\n      const {exceptionDetails, result: remoteObject} = await this._client.send('Runtime.evaluate', {\n        expression: expressionWithSourceUrl,\n        contextId,\n        returnByValue: false,\n        awaitPromise: true,\n        userGesture: true\n      }).catch(rewriteError);\n      if (exceptionDetails)\n        throw new Error('Evaluation failed: ' + helper.getExceptionMessage(exceptionDetails));\n      return this._objectHandleFactory(remoteObject);\n    }\n\n    if (typeof pageFunction !== 'function')\n      throw new Error('The following is not a function: ' + pageFunction);\n\n    const { exceptionDetails, result: remoteObject } = await this._client.send('Runtime.callFunctionOn', {\n      functionDeclaration: pageFunction.toString() + '\\n' + suffix + '\\n',\n      executionContextId: this._contextId,\n      arguments: args.map(convertArgument.bind(this)),\n      returnByValue: false,\n      awaitPromise: true,\n      userGesture: true\n    }).catch(rewriteError);\n    if (exceptionDetails)\n      throw new Error('Evaluation failed: ' + helper.getExceptionMessage(exceptionDetails));\n    return this._objectHandleFactory(remoteObject);\n\n    /**\n     * @param {*} arg\n     * @return {*}\n     * @this {ExecutionContext}\n     */\n    function convertArgument(arg) {\n      if (Object.is(arg, -0))\n        return { unserializableValue: '-0' };\n      if (Object.is(arg, Infinity))\n        return { unserializableValue: 'Infinity' };\n      if (Object.is(arg, -Infinity))\n        return { unserializableValue: '-Infinity' };\n      if (Object.is(arg, NaN))\n        return { unserializableValue: 'NaN' };\n      const objectHandle = arg && (arg instanceof JSHandle) ? arg : null;\n      if (objectHandle) {\n        if (objectHandle._context !== this)\n          throw new Error('JSHandles can be evaluated only in the context they were created!');\n        if (objectHandle._disposed)\n          throw new Error('JSHandle is disposed!');\n        if (objectHandle._remoteObject.unserializableValue)\n          return { unserializableValue: objectHandle._remoteObject.unserializableValue };\n        if (!objectHandle._remoteObject.objectId)\n          return { value: objectHandle._remoteObject.value };\n        return { objectId: objectHandle._remoteObject.objectId };\n      }\n      return { value: arg };\n    }\n\n    /**\n     * @param {!Error} error\n     * @return {!Protocol.Runtime.evaluateReturnValue}\n     */\n    function rewriteError(error) {\n      if (error.message.endsWith('Cannot find context with specified id'))\n        throw new Error('Execution context was destroyed, most likely because of a navigation.');\n      throw error;\n    }\n  }\n\n  /**\n   * @param {!JSHandle} prototypeHandle\n   * @return {!Promise<!JSHandle>}\n   */\n  async queryObjects(prototypeHandle) {\n    assert(!prototypeHandle._disposed, 'Prototype JSHandle is disposed!');\n    assert(prototypeHandle._remoteObject.objectId, 'Prototype JSHandle must not be referencing primitive value');\n    const response = await this._client.send('Runtime.queryObjects', {\n      prototypeObjectId: prototypeHandle._remoteObject.objectId\n    });\n    return this._objectHandleFactory(response.objects);\n  }\n}\n\nclass JSHandle {\n  /**\n   * @param {!ExecutionContext} context\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   */\n  constructor(context, client, remoteObject) {\n    this._context = context;\n    this._client = client;\n    this._remoteObject = remoteObject;\n    this._disposed = false;\n  }\n\n  /**\n   * @return {!ExecutionContext}\n   */\n  executionContext() {\n    return this._context;\n  }\n\n  /**\n   * @param {string} propertyName\n   * @return {!Promise<?JSHandle>}\n   */\n  async getProperty(propertyName) {\n    const objectHandle = await this._context.evaluateHandle((object, propertyName) => {\n      const result = {__proto__: null};\n      result[propertyName] = object[propertyName];\n      return result;\n    }, this, propertyName);\n    const properties = await objectHandle.getProperties();\n    const result = properties.get(propertyName) || null;\n    await objectHandle.dispose();\n    return result;\n  }\n\n  /**\n   * @return {!Promise<Map<string, !JSHandle>>}\n   */\n  async getProperties() {\n    const response = await this._client.send('Runtime.getProperties', {\n      objectId: this._remoteObject.objectId,\n      ownProperties: true\n    });\n    const result = new Map();\n    for (const property of response.result) {\n      if (!property.enumerable)\n        continue;\n      result.set(property.name, this._context._objectHandleFactory(property.value));\n    }\n    return result;\n  }\n\n  /**\n   * @return {!Promise<?Object>}\n   */\n  async jsonValue() {\n    if (this._remoteObject.objectId) {\n      const response = await this._client.send('Runtime.callFunctionOn', {\n        functionDeclaration: 'function() { return this; }',\n        objectId: this._remoteObject.objectId,\n        returnByValue: true,\n        awaitPromise: true,\n      });\n      return helper.valueFromRemoteObject(response.result);\n    }\n    return helper.valueFromRemoteObject(this._remoteObject);\n  }\n\n  /**\n   * @return {?Puppeteer.ElementHandle}\n   */\n  asElement() {\n    return null;\n  }\n\n  async dispose() {\n    if (this._disposed)\n      return;\n    this._disposed = true;\n    await helper.releaseObject(this._client, this._remoteObject);\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  toString() {\n    if (this._remoteObject.objectId) {\n      const type =  this._remoteObject.subtype || this._remoteObject.type;\n      return 'JSHandle@' + type;\n    }\n    return 'JSHandle:' + helper.valueFromRemoteObject(this._remoteObject);\n  }\n}\n\nhelper.tracePublicAPI(JSHandle);\nmodule.exports = {ExecutionContext, JSHandle, EVALUATION_SCRIPT_URL};\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst fs = require('fs');\nconst EventEmitter = require('events');\nconst {helper, assert} = require('./helper');\nconst {ExecutionContext, JSHandle} = require('./ExecutionContext');\nconst {ElementHandle} = require('./ElementHandle');\nconst {TimeoutError} = require('./Errors');\n\nconst readFileAsync = helper.promisify(fs.readFile);\n\nclass FrameManager extends EventEmitter {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Page.FrameTree} frameTree\n   * @param {!Puppeteer.Page} page\n   */\n  constructor(client, frameTree, page) {\n    super();\n    this._client = client;\n    this._page = page;\n    /** @type {!Map<string, !Frame>} */\n    this._frames = new Map();\n    /** @type {!Map<number, !ExecutionContext>} */\n    this._contextIdToContext = new Map();\n\n    this._client.on('Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId));\n    this._client.on('Page.frameNavigated', event => this._onFrameNavigated(event.frame));\n    this._client.on('Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url));\n    this._client.on('Page.frameDetached', event => this._onFrameDetached(event.frameId));\n    this._client.on('Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId));\n    this._client.on('Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context));\n    this._client.on('Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId));\n    this._client.on('Runtime.executionContextsCleared', event => this._onExecutionContextsCleared());\n    this._client.on('Page.lifecycleEvent', event => this._onLifecycleEvent(event));\n\n    this._handleFrameTree(frameTree);\n  }\n\n  /**\n   * @param {!Protocol.Page.lifecycleEventPayload} event\n   */\n  _onLifecycleEvent(event) {\n    const frame = this._frames.get(event.frameId);\n    if (!frame)\n      return;\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManager.Events.LifecycleEvent, frame);\n  }\n\n  /**\n   * @param {string} frameId\n   */\n  _onFrameStoppedLoading(frameId) {\n    const frame = this._frames.get(frameId);\n    if (!frame)\n      return;\n    frame._onLoadingStopped();\n    this.emit(FrameManager.Events.LifecycleEvent, frame);\n  }\n\n  /**\n   * @param {!Protocol.Page.FrameTree} frameTree\n   */\n  _handleFrameTree(frameTree) {\n    if (frameTree.frame.parentId)\n      this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);\n    this._onFrameNavigated(frameTree.frame);\n    if (!frameTree.childFrames)\n      return;\n\n    for (const child of frameTree.childFrames)\n      this._handleFrameTree(child);\n  }\n\n  /**\n   * @return {!Frame}\n   */\n  mainFrame() {\n    return this._mainFrame;\n  }\n\n  /**\n   * @return {!Array<!Frame>}\n   */\n  frames() {\n    return Array.from(this._frames.values());\n  }\n\n  /**\n   * @param {!string} frameId\n   * @return {?Frame}\n   */\n  frame(frameId) {\n    return this._frames.get(frameId) || null;\n  }\n\n  /**\n   * @param {string} frameId\n   * @param {?string} parentFrameId\n   * @return {?Frame}\n   */\n  _onFrameAttached(frameId, parentFrameId) {\n    if (this._frames.has(frameId))\n      return;\n    assert(parentFrameId);\n    const parentFrame = this._frames.get(parentFrameId);\n    const frame = new Frame(this._client, parentFrame, frameId);\n    this._frames.set(frame._id, frame);\n    this.emit(FrameManager.Events.FrameAttached, frame);\n  }\n\n  /**\n   * @param {!Protocol.Page.Frame} framePayload\n   */\n  _onFrameNavigated(framePayload) {\n    const isMainFrame = !framePayload.parentId;\n    let frame = isMainFrame ? this._mainFrame : this._frames.get(framePayload.id);\n    assert(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame');\n\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames())\n        this._removeFramesRecursively(child);\n    }\n\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frames.delete(frame._id);\n        frame._id = framePayload.id;\n      } else {\n        // Initial main frame navigation.\n        frame = new Frame(this._client, null, framePayload.id);\n      }\n      this._frames.set(framePayload.id, frame);\n      this._mainFrame = frame;\n    }\n\n    // Update frame payload.\n    frame._navigated(framePayload);\n\n    this.emit(FrameManager.Events.FrameNavigated, frame);\n  }\n\n  /**\n   * @param {string} frameId\n   * @param {string} url\n   */\n  _onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this._frames.get(frameId);\n    if (!frame)\n      return;\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManager.Events.FrameNavigatedWithinDocument, frame);\n    this.emit(FrameManager.Events.FrameNavigated, frame);\n  }\n\n  /**\n   * @param {string} frameId\n   */\n  _onFrameDetached(frameId) {\n    const frame = this._frames.get(frameId);\n    if (frame)\n      this._removeFramesRecursively(frame);\n  }\n\n  _onExecutionContextCreated(contextPayload) {\n    const frameId = contextPayload.auxData ? contextPayload.auxData.frameId : null;\n    const frame = this._frames.get(frameId) || null;\n    /** @type {!ExecutionContext} */\n    const context = new ExecutionContext(this._client, contextPayload, obj => this.createJSHandle(context, obj), frame);\n    this._contextIdToContext.set(contextPayload.id, context);\n    if (frame)\n      frame._addExecutionContext(context);\n  }\n\n  /**\n   * @param {number} executionContextId\n   */\n  _onExecutionContextDestroyed(executionContextId) {\n    const context = this._contextIdToContext.get(executionContextId);\n    if (!context)\n      return;\n    this._contextIdToContext.delete(executionContextId);\n    if (context.frame())\n      context.frame()._removeExecutionContext(context);\n  }\n\n  _onExecutionContextsCleared() {\n    for (const context of this._contextIdToContext.values()) {\n      if (context.frame())\n        context.frame()._removeExecutionContext(context);\n    }\n    this._contextIdToContext.clear();\n  }\n\n  /**\n   * @param {number} contextId\n   * @return {!ExecutionContext}\n   */\n  executionContextById(contextId) {\n    const context = this._contextIdToContext.get(contextId);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  /**\n   * @param {!ExecutionContext} context\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   * @return {!JSHandle}\n   */\n  createJSHandle(context, remoteObject) {\n    if (remoteObject.subtype === 'node')\n      return new ElementHandle(context, this._client, remoteObject, this._page, this);\n    return new JSHandle(context, this._client, remoteObject);\n  }\n\n  /**\n   * @param {!Frame} frame\n   */\n  _removeFramesRecursively(frame) {\n    for (const child of frame.childFrames())\n      this._removeFramesRecursively(child);\n    frame._detach();\n    this._frames.delete(frame._id);\n    this.emit(FrameManager.Events.FrameDetached, frame);\n  }\n}\n\n/** @enum {string} */\nFrameManager.Events = {\n  FrameAttached: 'frameattached',\n  FrameNavigated: 'framenavigated',\n  FrameDetached: 'framedetached',\n  LifecycleEvent: 'lifecycleevent',\n  FrameNavigatedWithinDocument: 'framenavigatedwithindocument',\n  ExecutionContextCreated: 'executioncontextcreated',\n  ExecutionContextDestroyed: 'executioncontextdestroyed',\n};\n\n/**\n * @unrestricted\n */\nclass Frame {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {?Frame} parentFrame\n   * @param {string} frameId\n   */\n  constructor(client, parentFrame, frameId) {\n    this._client = client;\n    this._parentFrame = parentFrame;\n    this._url = '';\n    this._id = frameId;\n\n    /** @type {?Promise<!ElementHandle>} */\n    this._documentPromise = null;\n    /** @type {?Promise<!ExecutionContext>} */\n    this._contextPromise = null;\n    this._contextResolveCallback = null;\n    this._setDefaultContext(null);\n\n    /** @type {!Set<!WaitTask>} */\n    this._waitTasks = new Set();\n    this._loaderId = '';\n    /** @type {!Set<string>} */\n    this._lifecycleEvents = new Set();\n\n    /** @type {!Set<!Frame>} */\n    this._childFrames = new Set();\n    if (this._parentFrame)\n      this._parentFrame._childFrames.add(this);\n  }\n\n  /**\n   * @param {!ExecutionContext} context\n   */\n  _addExecutionContext(context) {\n    if (context._isDefault)\n      this._setDefaultContext(context);\n  }\n\n  /**\n   * @param {!ExecutionContext} context\n   */\n  _removeExecutionContext(context) {\n    if (context._isDefault)\n      this._setDefaultContext(null);\n  }\n\n  /**\n   * @param {?ExecutionContext} context\n   */\n  _setDefaultContext(context) {\n    if (context) {\n      this._contextResolveCallback.call(null, context);\n      this._contextResolveCallback = null;\n      for (const waitTask of this._waitTasks)\n        waitTask.rerun();\n    } else {\n      this._documentPromise = null;\n      this._contextPromise = new Promise(fulfill => {\n        this._contextResolveCallback = fulfill;\n      });\n    }\n  }\n\n  /**\n   * @return {!Promise<!ExecutionContext>}\n   */\n  executionContext() {\n    return this._contextPromise;\n  }\n\n  /**\n   * @param {function()|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<!Puppeteer.JSHandle>}\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    const context = await this._contextPromise;\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<*>}\n   */\n  async evaluate(pageFunction, ...args) {\n    const context = await this._contextPromise;\n    return context.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<?ElementHandle>}\n   */\n  async $(selector) {\n    const document = await this._document();\n    const value = await document.$(selector);\n    return value;\n  }\n\n  /**\n   * @return {!Promise<!ElementHandle>}\n   */\n  async _document() {\n    if (this._documentPromise)\n      return this._documentPromise;\n    this._documentPromise = this._contextPromise.then(async context => {\n      const document = await context.evaluateHandle('document');\n      return document.asElement();\n    });\n    return this._documentPromise;\n  }\n\n  /**\n   * @param {string} expression\n   * @return {!Promise<!Array<!ElementHandle>>}\n   */\n  async $x(expression) {\n    const document = await this._document();\n    const value = await document.$x(expression);\n    return value;\n  }\n\n  /**\n   * @param {string} selector\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    return document.$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * @param {string} selector\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $$eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    const value = await document.$$eval(selector, pageFunction, ...args);\n    return value;\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<!Array<!ElementHandle>>}\n   */\n  async $$(selector) {\n    const document = await this._document();\n    const value = await document.$$(selector);\n    return value;\n  }\n\n  /**\n   * @return {!Promise<String>}\n   */\n  async content() {\n    return await this.evaluate(() => {\n      let retVal = '';\n      if (document.doctype)\n        retVal = new XMLSerializer().serializeToString(document.doctype);\n      if (document.documentElement)\n        retVal += document.documentElement.outerHTML;\n      return retVal;\n    });\n  }\n\n  /**\n   * @param {string} html\n   */\n  async setContent(html) {\n    await this.evaluate(html => {\n      document.open();\n      document.write(html);\n      document.close();\n    }, html);\n  }\n\n  /**\n   * @return {string}\n   */\n  name() {\n    return this._name || '';\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {?Frame}\n   */\n  parentFrame() {\n    return this._parentFrame;\n  }\n\n  /**\n   * @return {!Array.<!Frame>}\n   */\n  childFrames() {\n    return Array.from(this._childFrames);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isDetached() {\n    return this._detached;\n  }\n\n  /**\n   * @param {Object} options\n   * @return {!Promise<!ElementHandle>}\n   */\n  async addScriptTag(options) {\n    if (typeof options.url === 'string') {\n      const url = options.url;\n      try {\n        const context = await this._contextPromise;\n        return (await context.evaluateHandle(addScriptUrl, url, options.type)).asElement();\n      } catch (error) {\n        throw new Error(`Loading script from ${url} failed`);\n      }\n    }\n\n    if (typeof options.path === 'string') {\n      let contents = await readFileAsync(options.path, 'utf8');\n      contents += '//# sourceURL=' + options.path.replace(/\\n/g, '');\n      const context = await this._contextPromise;\n      return (await context.evaluateHandle(addScriptContent, contents, options.type)).asElement();\n    }\n\n    if (typeof options.content === 'string') {\n      const context = await this._contextPromise;\n      return (await context.evaluateHandle(addScriptContent, options.content, options.type)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    /**\n     * @param {string} url\n     * @param {string} type\n     * @return {!Promise<!HTMLElement>}\n     */\n    async function addScriptUrl(url, type) {\n      const script = document.createElement('script');\n      script.src = url;\n      if (type)\n        script.type = type;\n      const promise = new Promise((res, rej) => {\n        script.onload = res;\n        script.onerror = rej;\n      });\n      document.head.appendChild(script);\n      await promise;\n      return script;\n    }\n\n    /**\n     * @param {string} content\n     * @param {string} type\n     * @return {!HTMLElement}\n     */\n    function addScriptContent(content, type = 'text/javascript') {\n      const script = document.createElement('script');\n      script.type = type;\n      script.text = content;\n      let error = null;\n      script.onerror = e => error = e;\n      document.head.appendChild(script);\n      if (error)\n        throw error;\n      return script;\n    }\n  }\n\n  /**\n   * @param {Object} options\n   * @return {!Promise<!ElementHandle>}\n   */\n  async addStyleTag(options) {\n    if (typeof options.url === 'string') {\n      const url = options.url;\n      try {\n        const context = await this._contextPromise;\n        return (await context.evaluateHandle(addStyleUrl, url)).asElement();\n      } catch (error) {\n        throw new Error(`Loading style from ${url} failed`);\n      }\n    }\n\n    if (typeof options.path === 'string') {\n      let contents = await readFileAsync(options.path, 'utf8');\n      contents += '/*# sourceURL=' + options.path.replace(/\\n/g, '') + '*/';\n      const context = await this._contextPromise;\n      return (await context.evaluateHandle(addStyleContent, contents)).asElement();\n    }\n\n    if (typeof options.content === 'string') {\n      const context = await this._contextPromise;\n      return (await context.evaluateHandle(addStyleContent, options.content)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    /**\n     * @param {string} url\n     * @return {!Promise<!HTMLElement>}\n     */\n    async function addStyleUrl(url) {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = url;\n      const promise = new Promise((res, rej) => {\n        link.onload = res;\n        link.onerror = rej;\n      });\n      document.head.appendChild(link);\n      await promise;\n      return link;\n    }\n\n    /**\n     * @param {string} content\n     * @return {!Promise<!HTMLElement>}\n     */\n    async function addStyleContent(content) {\n      const style = document.createElement('style');\n      style.type = 'text/css';\n      style.appendChild(document.createTextNode(content));\n      const promise = new Promise((res, rej) => {\n        style.onload = res;\n        style.onerror = rej;\n      });\n      document.head.appendChild(style);\n      await promise;\n      return style;\n    }\n  }\n\n  /**\n   * @param {string} selector\n   * @param {!Object=} options\n   */\n  async click(selector, options = {}) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.click(options);\n    await handle.dispose();\n  }\n\n  /**\n   * @param {string} selector\n   */\n  async focus(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.focus();\n    await handle.dispose();\n  }\n\n  /**\n   * @param {string} selector\n   */\n  async hover(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.hover();\n    await handle.dispose();\n  }\n\n  /**\n  * @param {string} selector\n  * @param {!Array<string>} values\n  * @return {!Promise<!Array<string>>}\n  */\n  select(selector, ...values){\n    for (const value of values)\n      assert(helper.isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + (typeof value) + '\"');\n    return this.$eval(selector, (element, values) => {\n      if (element.nodeName.toLowerCase() !== 'select')\n        throw new Error('Element is not a <select> element.');\n\n      const options = Array.from(element.options);\n      element.value = undefined;\n      for (const option of options) {\n        option.selected = values.includes(option.value);\n        if (option.selected && !element.multiple)\n          break;\n      }\n      element.dispatchEvent(new Event('input', { 'bubbles': true }));\n      element.dispatchEvent(new Event('change', { 'bubbles': true }));\n      return options.filter(option => option.selected).map(option => option.value);\n    }, values);\n  }\n\n  /**\n   * @param {string} selector\n   */\n  async tap(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.tap();\n    await handle.dispose();\n  }\n\n  /**\n   * @param {string} selector\n   * @param {string} text\n   * @param {{delay: (number|undefined)}=} options\n   */\n  async type(selector, text, options) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.type(text, options);\n    await handle.dispose();\n  }\n\n  /**\n   * @param {(string|number|Function)} selectorOrFunctionOrTimeout\n   * @param {!Object=} options\n   * @param {!Array<*>} args\n   * @return {!Promise}\n   */\n  waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n    const xPathPattern = '//';\n\n    if (helper.isString(selectorOrFunctionOrTimeout)) {\n      const string = /** @type {string} */ (selectorOrFunctionOrTimeout);\n      if (string.startsWith(xPathPattern))\n        return this.waitForXPath(string, options);\n      return this.waitForSelector(string, options);\n    }\n    if (helper.isNumber(selectorOrFunctionOrTimeout))\n      return new Promise(fulfill => setTimeout(fulfill, selectorOrFunctionOrTimeout));\n    if (typeof selectorOrFunctionOrTimeout === 'function')\n      return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);\n    return Promise.reject(new Error('Unsupported target type: ' + (typeof selectorOrFunctionOrTimeout)));\n  }\n\n  /**\n   * @param {string} selector\n   * @param {!Object=} options\n   * @return {!Promise}\n   */\n  waitForSelector(selector, options = {}) {\n    return this._waitForSelectorOrXPath(selector, false, options);\n  }\n\n  /**\n   * @param {string} xpath\n   * @param {!Object=} options\n   * @return {!Promise}\n   */\n  waitForXPath(xpath, options = {}) {\n    return this._waitForSelectorOrXPath(xpath, true, options);\n  }\n\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!Object=} options\n   * @return {!Promise}\n   */\n  waitForFunction(pageFunction, options = {}, ...args) {\n    const timeout = helper.isNumber(options.timeout) ? options.timeout : 30000;\n    const polling = options.polling || 'raf';\n    return new WaitTask(this, pageFunction, 'function', polling, timeout, ...args).promise;\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async title() {\n    return this.evaluate(() => document.title);\n  }\n\n  /**\n   * @param {string} selectorOrXPath\n   * @param {boolean} isXPath\n   * @param {!Object=} options\n   * @return {!Promise}\n   */\n  _waitForSelectorOrXPath(selectorOrXPath, isXPath, options = {}) {\n    const waitForVisible = !!options.visible;\n    const waitForHidden = !!options.hidden;\n    const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n    const timeout = helper.isNumber(options.timeout) ? options.timeout : 30000;\n    const title = `${isXPath ? 'XPath' : 'selector'} \"${selectorOrXPath}\"${waitForHidden ? ' to be hidden' : ''}`;\n    return new WaitTask(this, predicate, title, polling, timeout, selectorOrXPath, isXPath, waitForVisible, waitForHidden).promise;\n\n    /**\n     * @param {string} selectorOrXPath\n     * @param {boolean} isXPath\n     * @param {boolean} waitForVisible\n     * @param {boolean} waitForHidden\n     * @return {?Node|boolean}\n     */\n    function predicate(selectorOrXPath, isXPath, waitForVisible, waitForHidden) {\n      const node = isXPath\n        ? document.evaluate(selectorOrXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue\n        : document.querySelector(selectorOrXPath);\n      if (!node)\n        return waitForHidden;\n      if (!waitForVisible && !waitForHidden)\n        return node;\n      const element = /** @type {Element} */ (node.nodeType === Node.TEXT_NODE ? node.parentElement : node);\n\n      const style = window.getComputedStyle(element);\n      const isVisible = style && style.visibility !== 'hidden' && hasVisibleBoundingBox();\n      const success = (waitForVisible === isVisible || waitForHidden === !isVisible);\n      return success ? node : null;\n\n      /**\n       * @return {boolean}\n       */\n      function hasVisibleBoundingBox() {\n        const rect = element.getBoundingClientRect();\n        return !!(rect.top || rect.bottom || rect.width || rect.height);\n      }\n    }\n  }\n\n  /**\n   * @param {!Protocol.Page.Frame} framePayload\n   */\n  _navigated(framePayload) {\n    this._name = framePayload.name;\n    // TODO(lushnikov): remove this once requestInterception has loaderId exposed.\n    this._navigationURL = framePayload.url;\n    this._url = framePayload.url;\n  }\n\n  /**\n   * @param {string} url\n   */\n  _navigatedWithinDocument(url) {\n    this._url = url;\n  }\n\n  /**\n   * @param {string} loaderId\n   * @param {string} name\n   */\n  _onLifecycleEvent(loaderId, name) {\n    if (name === 'init') {\n      this._loaderId = loaderId;\n      this._lifecycleEvents.clear();\n    }\n    this._lifecycleEvents.add(name);\n  }\n\n  _onLoadingStopped() {\n    this._lifecycleEvents.add('DOMContentLoaded');\n    this._lifecycleEvents.add('load');\n  }\n\n  _detach() {\n    for (const waitTask of this._waitTasks)\n      waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));\n    this._detached = true;\n    if (this._parentFrame)\n      this._parentFrame._childFrames.delete(this);\n    this._parentFrame = null;\n  }\n}\nhelper.tracePublicAPI(Frame);\n\nclass WaitTask {\n  /**\n   * @param {!Frame} frame\n   * @param {Function|string} predicateBody\n   * @param {string|number} polling\n   * @param {number} timeout\n   * @param {!Array<*>} args\n   */\n  constructor(frame, predicateBody, title, polling, timeout, ...args) {\n    if (helper.isString(polling))\n      assert(polling === 'raf' || polling === 'mutation', 'Unknown polling option: ' + polling);\n    else if (helper.isNumber(polling))\n      assert(polling > 0, 'Cannot poll with non-positive interval: ' + polling);\n    else\n      throw new Error('Unknown polling options: ' + polling);\n\n    this._frame = frame;\n    this._polling = polling;\n    this._timeout = timeout;\n    this._predicateBody = helper.isString(predicateBody) ? 'return ' + predicateBody : 'return (' + predicateBody + ')(...args)';\n    this._args = args;\n    this._runCount = 0;\n    frame._waitTasks.add(this);\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    // Since page navigation requires us to re-install the pageScript, we should track\n    // timeout on our end.\n    if (timeout) {\n      const timeoutError = new TimeoutError(`waiting for ${title} failed: timeout ${timeout}ms exceeded`);\n      this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), timeout);\n    }\n    this.rerun();\n  }\n\n  /**\n   * @param {!Error} error\n   */\n  terminate(error) {\n    this._terminated = true;\n    this._reject(error);\n    this._cleanup();\n  }\n\n  async rerun() {\n    const runCount = ++this._runCount;\n    /** @type {?JSHandle} */\n    let success = null;\n    let error = null;\n    try {\n      success = await (await this._frame.executionContext()).evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);\n    } catch (e) {\n      error = e;\n    }\n\n    if (this._terminated || runCount !== this._runCount) {\n      if (success)\n        await success.dispose();\n      return;\n    }\n\n    // Ignore timeouts in pageScript - we track timeouts ourselves.\n    // If the frame's execution context has already changed, `frame.evaluate` will\n    // throw an error - ignore this predicate run altogether.\n    if (!error && await this._frame.evaluate(s => !s, success).catch(e => true)) {\n      await success.dispose();\n      return;\n    }\n\n    // When the page is navigated, the promise is rejected.\n    // We will try again in the new execution context.\n    if (error && error.message.includes('Execution context was destroyed'))\n      return;\n\n    // We could have tried to evaluate in a context which was already\n    // destroyed.\n    if (error && error.message.includes('Cannot find context with specified id'))\n      return;\n\n    if (error)\n      this._reject(error);\n    else\n      this._resolve(success);\n\n    this._cleanup();\n  }\n\n  _cleanup() {\n    clearTimeout(this._timeoutTimer);\n    this._frame._waitTasks.delete(this);\n    this._runningTask = null;\n  }\n}\n\n/**\n * @param {string} predicateBody\n * @param {string} polling\n * @param {number} timeout\n * @return {!Promise<*>}\n */\nasync function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {\n  const predicate = new Function('...args', predicateBody);\n  let timedOut = false;\n  if (timeout)\n    setTimeout(() => timedOut = true, timeout);\n  if (polling === 'raf')\n    return await pollRaf();\n  if (polling === 'mutation')\n    return await pollMutation();\n  if (typeof polling === 'number')\n    return await pollInterval(polling);\n\n  /**\n   * @return {!Promise<*>}\n   */\n  function pollMutation() {\n    const success = predicate.apply(null, args);\n    if (success)\n      return Promise.resolve(success);\n\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    const observer = new MutationObserver(mutations => {\n      if (timedOut) {\n        observer.disconnect();\n        fulfill();\n      }\n      const success = predicate.apply(null, args);\n      if (success) {\n        observer.disconnect();\n        fulfill(success);\n      }\n    });\n    observer.observe(document, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return result;\n  }\n\n  /**\n   * @return {!Promise<*>}\n   */\n  function pollRaf() {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    onRaf();\n    return result;\n\n    function onRaf() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n      const success = predicate.apply(null, args);\n      if (success)\n        fulfill(success);\n      else\n        requestAnimationFrame(onRaf);\n    }\n  }\n\n  /**\n   * @param {number} pollInterval\n   * @return {!Promise<*>}\n   */\n  function pollInterval(pollInterval) {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    onTimeout();\n    return result;\n\n    function onTimeout() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n      const success = predicate.apply(null, args);\n      if (success)\n        fulfill(success);\n      else\n        setTimeout(onTimeout, pollInterval);\n    }\n  }\n}\n\nmodule.exports = {FrameManager, Frame};\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {helper, assert} = require('./helper');\nconst keyDefinitions = require('./USKeyboardLayout');\n\n/**\n * @typedef {Object} KeyDescription\n * @property {number} keyCode\n * @property {string} key\n * @property {string} text\n * @property {string} code\n * @property {number} location\n */\n\nclass Keyboard {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._modifiers = 0;\n    this._pressedKeys = new Set();\n  }\n\n  /**\n   * @param {string} key\n   * @param {{text: string}=} options\n   */\n  async down(key, options = { text: undefined }) {\n    const description = this._keyDescriptionForString(key);\n\n    const autoRepeat = this._pressedKeys.has(description.code);\n    this._pressedKeys.add(description.code);\n    this._modifiers |= this._modifierBit(description.key);\n\n    const text = options.text === undefined ? description.text : options.text;\n    await this._client.send('Input.dispatchKeyEvent', {\n      type: text ? 'keyDown' : 'rawKeyDown',\n      modifiers: this._modifiers,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      key: description.key,\n      text: text,\n      unmodifiedText: text,\n      autoRepeat,\n      location: description.location,\n      isKeypad: description.location === 3\n    });\n  }\n\n  /**\n   * @param {string} key\n   * @return {number}\n   */\n  _modifierBit(key) {\n    if (key === 'Alt')\n      return 1;\n    if (key === 'Control')\n      return 2;\n    if (key === 'Meta')\n      return 4;\n    if (key === 'Shift')\n      return 8;\n    return 0;\n  }\n\n  /**\n   * @param {string} keyString\n   * @return {KeyDescription}\n   */\n  _keyDescriptionForString(keyString) {\n    const shift = this._modifiers & 8;\n    const description = {\n      key: '',\n      keyCode: 0,\n      code: '',\n      text: '',\n      location: 0\n    };\n\n    const definition = keyDefinitions[keyString];\n    assert(definition, `Unknown key: \"${keyString}\"`);\n\n    if (definition.key)\n      description.key = definition.key;\n    if (shift && definition.shiftKey)\n      description.key = definition.shiftKey;\n\n    if (definition.keyCode)\n      description.keyCode = definition.keyCode;\n    if (shift && definition.shiftKeyCode)\n      description.keyCode = definition.shiftKeyCode;\n\n    if (definition.code)\n      description.code = definition.code;\n\n    if (definition.location)\n      description.location = definition.location;\n\n    if (description.key.length === 1)\n      description.text = description.key;\n\n    if (definition.text)\n      description.text = definition.text;\n    if (shift && definition.shiftText)\n      description.text = definition.shiftText;\n\n    // if any modifiers besides shift are pressed, no text should be sent\n    if (this._modifiers & ~8)\n      description.text = '';\n\n    return description;\n  }\n\n  /**\n   * @param {string} key\n   */\n  async up(key) {\n    const description = this._keyDescriptionForString(key);\n\n    this._modifiers &= ~this._modifierBit(description.key);\n    this._pressedKeys.delete(description.code);\n    await this._client.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: this._modifiers,\n      key: description.key,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      location: description.location\n    });\n  }\n\n  /**\n   * @param {string} char\n   */\n  async sendCharacter(char) {\n    await this._client.send('Input.insertText', {text: char});\n  }\n\n  /**\n   * @param {string} text\n   * @param {{delay: (number|undefined)}=} options\n   */\n  async type(text, options) {\n    let delay = 0;\n    if (options && options.delay)\n      delay = options.delay;\n    for (const char of text) {\n      if (keyDefinitions[char])\n        await this.press(char, {delay});\n      else\n        await this.sendCharacter(char);\n      if (delay)\n        await new Promise(f => setTimeout(f, delay));\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {!Object=} options\n   */\n  async press(key, options) {\n    await this.down(key, options);\n    if (options && options.delay)\n      await new Promise(f => setTimeout(f, options.delay));\n    await this.up(key);\n  }\n}\n\nclass Mouse {\n  /**\n   * @param {Puppeteer.CDPSession} client\n   * @param {!Keyboard} keyboard\n   */\n  constructor(client, keyboard) {\n    this._client = client;\n    this._keyboard = keyboard;\n    this._x = 0;\n    this._y = 0;\n    /** @type {'none'|'left'|'right'|'middle'} */\n    this._button = 'none';\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   * @param {Object=} options\n   * @return {!Promise}\n   */\n  async move(x, y, options = {}) {\n    const fromX = this._x, fromY = this._y;\n    this._x = x;\n    this._y = y;\n    const steps = options.steps || 1;\n    for (let i = 1; i <= steps; i++) {\n      await this._client.send('Input.dispatchMouseEvent', {\n        type: 'mouseMoved',\n        button: this._button,\n        x: fromX + (this._x - fromX) * (i / steps),\n        y: fromY + (this._y - fromY) * (i / steps),\n        modifiers: this._keyboard._modifiers\n      });\n    }\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   * @param {!Object=} options\n   */\n  async click(x, y, options = {}) {\n    this.move(x, y);\n    this.down(options);\n    if (typeof options.delay === 'number')\n      await new Promise(f => setTimeout(f, options.delay));\n    await this.up(options);\n  }\n\n  /**\n   * @param {!Object=} options\n   */\n  async down(options = {}) {\n    this._button = (options.button || 'left');\n    await this._client.send('Input.dispatchMouseEvent', {\n      type: 'mousePressed',\n      button: this._button,\n      x: this._x,\n      y: this._y,\n      modifiers: this._keyboard._modifiers,\n      clickCount: (options.clickCount || 1)\n    });\n  }\n\n  /**\n   * @param {!Object=} options\n   */\n  async up(options = {}) {\n    this._button = 'none';\n    await this._client.send('Input.dispatchMouseEvent', {\n      type: 'mouseReleased',\n      button: (options.button || 'left'),\n      x: this._x,\n      y: this._y,\n      modifiers: this._keyboard._modifiers,\n      clickCount: (options.clickCount || 1)\n    });\n  }\n}\n\nclass Touchscreen {\n  /**\n   * @param {Puppeteer.CDPSession} client\n   * @param {Keyboard} keyboard\n   */\n  constructor(client, keyboard) {\n    this._client = client;\n    this._keyboard = keyboard;\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  async tap(x, y) {\n    // Touches appear to be lost during the first frame after navigation.\n    // This waits a frame before sending the tap.\n    // @see https://crbug.com/613219\n    await this._client.send('Runtime.evaluate', {\n      expression: 'new Promise(x => requestAnimationFrame(() => requestAnimationFrame(x)))',\n      awaitPromise: true\n    });\n\n    const touchPoints = [{x: Math.round(x), y: Math.round(y)}];\n    await this._client.send('Input.dispatchTouchEvent', {\n      type: 'touchStart',\n      touchPoints,\n      modifiers: this._keyboard._modifiers\n    });\n    await this._client.send('Input.dispatchTouchEvent', {\n      type: 'touchEnd',\n      touchPoints: [],\n      modifiers: this._keyboard._modifiers\n    });\n  }\n}\n\nmodule.exports = { Keyboard, Mouse, Touchscreen};\nhelper.tracePublicAPI(Keyboard);\nhelper.tracePublicAPI(Mouse);\nhelper.tracePublicAPI(Touchscreen);\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @template T\n * @template V\n */\nclass Multimap {\n  constructor() {\n    this._map = new Map();\n  }\n\n  /**\n   * @param {T} key\n   * @param {V} value\n   */\n  set(key, value) {\n    let set = this._map.get(key);\n    if (!set) {\n      set = new Set();\n      this._map.set(key, set);\n    }\n    set.add(value);\n  }\n\n  /**\n   * @param {T} key\n   * @return {!Set<V>}\n   */\n  get(key) {\n    let result = this._map.get(key);\n    if (!result)\n      result = new Set();\n    return result;\n  }\n\n  /**\n   * @param {T} key\n   * @return {boolean}\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n\n  /**\n   * @param {T} key\n   * @param {V} value\n   * @return {boolean}\n   */\n  hasValue(key, value) {\n    const set = this._map.get(key);\n    if (!set)\n      return false;\n    return set.has(value);\n  }\n\n  /**\n   * @return {number}\n   */\n  get size() {\n    return this._map.size;\n  }\n\n  /**\n   * @param {T} key\n   * @param {V} value\n   * @return {boolean}\n   */\n  delete(key, value) {\n    const values = this.get(key);\n    const result = values.delete(value);\n    if (!values.size)\n      this._map.delete(key);\n    return result;\n  }\n\n  /**\n   * @param {T} key\n   */\n  deleteAll(key) {\n    this._map.delete(key);\n  }\n\n  /**\n   * @param {T} key\n   * @return {V}\n   */\n  firstValue(key) {\n    const set = this._map.get(key);\n    if (!set)\n      return null;\n    return set.values().next().value;\n  }\n\n  /**\n   * @return {T}\n   */\n  firstKey() {\n    return this._map.keys().next().value;\n  }\n\n  /**\n   * @return {!Array<V>}\n   */\n  valuesArray() {\n    const result = [];\n    for (const key of this._map.keys())\n      result.push(...Array.from(this._map.get(key).values()));\n    return result;\n  }\n\n  /**\n   * @return {!Array<T>}\n   */\n  keysArray() {\n    return Array.from(this._map.keys());\n  }\n\n  clear() {\n    this._map.clear();\n  }\n}\n\nmodule.exports = Multimap;\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {helper, assert} = require('./helper');\nconst {FrameManager} = require('./FrameManager');\nconst {TimeoutError} = require('./Errors');\n\nclass NavigatorWatcher {\n  /**\n   * @param {!FrameManager} frameManager\n   * @param {!Puppeteer.Frame} frame\n   * @param {number} timeout\n   * @param {!Object=} options\n   */\n  constructor(frameManager, frame, timeout, options = {}) {\n    assert(options.networkIdleTimeout === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');\n    assert(options.networkIdleInflight === undefined, 'ERROR: networkIdleInflight option is no longer supported.');\n    assert(options.waitUntil !== 'networkidle', 'ERROR: \"networkidle\" option is no longer supported. Use \"networkidle2\" instead');\n    let waitUntil = ['load'];\n    if (Array.isArray(options.waitUntil))\n      waitUntil = options.waitUntil.slice();\n    else if (typeof options.waitUntil === 'string')\n      waitUntil = [options.waitUntil];\n    this._expectedLifecycle = waitUntil.map(value => {\n      const protocolEvent = puppeteerToProtocolLifecycle[value];\n      assert(protocolEvent, 'Unknown value for options.waitUntil: ' + value);\n      return protocolEvent;\n    });\n\n    this._frameManager = frameManager;\n    this._frame = frame;\n    this._initialLoaderId = frame._loaderId;\n    this._timeout = timeout;\n    this._hasSameDocumentNavigation = false;\n    this._eventListeners = [\n      helper.addEventListener(this._frameManager, FrameManager.Events.LifecycleEvent, this._checkLifecycleComplete.bind(this)),\n      helper.addEventListener(this._frameManager, FrameManager.Events.FrameNavigatedWithinDocument, this._navigatedWithinDocument.bind(this)),\n      helper.addEventListener(this._frameManager, FrameManager.Events.FrameDetached, this._checkLifecycleComplete.bind(this))\n    ];\n\n    const lifecycleCompletePromise = new Promise(fulfill => {\n      this._lifecycleCompleteCallback = fulfill;\n    });\n    this._navigationPromise = Promise.race([\n      this._createTimeoutPromise(),\n      lifecycleCompletePromise\n    ]).then(error => {\n      this._cleanup();\n      return error;\n    });\n  }\n\n  /**\n   * @return {!Promise<?Error>}\n   */\n  _createTimeoutPromise() {\n    if (!this._timeout)\n      return new Promise(() => {});\n    const errorMessage = 'Navigation Timeout Exceeded: ' + this._timeout + 'ms exceeded';\n    return new Promise(fulfill => this._maximumTimer = setTimeout(fulfill, this._timeout))\n        .then(() => new TimeoutError(errorMessage));\n  }\n\n  /**\n   * @return {!Promise<?Error>}\n   */\n  async navigationPromise() {\n    return this._navigationPromise;\n  }\n\n  /**\n   * @param {!Puppeteer.Frame} frame\n   */\n  _navigatedWithinDocument(frame) {\n    if (frame !== this._frame)\n      return;\n    this._hasSameDocumentNavigation = true;\n    this._checkLifecycleComplete();\n  }\n\n  _checkLifecycleComplete() {\n    // We expect navigation to commit.\n    if (this._frame._loaderId === this._initialLoaderId && !this._hasSameDocumentNavigation)\n      return;\n    if (!checkLifecycle(this._frame, this._expectedLifecycle))\n      return;\n    this._lifecycleCompleteCallback();\n\n    /**\n     * @param {!Puppeteer.Frame} frame\n     * @param {!Array<string>} expectedLifecycle\n     * @return {boolean}\n     */\n    function checkLifecycle(frame, expectedLifecycle) {\n      for (const event of expectedLifecycle) {\n        if (!frame._lifecycleEvents.has(event))\n          return false;\n      }\n      for (const child of frame.childFrames()) {\n        if (!checkLifecycle(child, expectedLifecycle))\n          return false;\n      }\n      return true;\n    }\n  }\n\n  cancel() {\n    this._cleanup();\n  }\n\n  _cleanup() {\n    helper.removeEventListeners(this._eventListeners);\n    this._lifecycleCompleteCallback(new Error('Navigation failed'));\n    clearTimeout(this._maximumTimer);\n  }\n}\n\nconst puppeteerToProtocolLifecycle = {\n  'load': 'load',\n  'domcontentloaded': 'DOMContentLoaded',\n  'networkidle0': 'networkIdle',\n  'networkidle2': 'networkAlmostIdle',\n};\n\nmodule.exports = {NavigatorWatcher};\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter = require('events');\nconst {helper, assert, debugError} = require('./helper');\nconst Multimap = require('./Multimap');\n\nclass NetworkManager extends EventEmitter {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Puppeteer.FrameManager} frameManager\n   */\n  constructor(client, frameManager) {\n    super();\n    this._client = client;\n    this._frameManager = frameManager;\n    /** @type {!Map<string, !Request>} */\n    this._requestIdToRequest = new Map();\n    /** @type {!Map<string, !Protocol.Network.requestWillBeSentPayload>} */\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    /** @type {!Object<string, string>} */\n    this._extraHTTPHeaders = {};\n\n    this._offline = false;\n\n    /** @type {?{username: string, password: string}} */\n    this._credentials = null;\n    /** @type {!Set<string>} */\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    /** @type {!Multimap<string, string>} */\n    this._requestHashToRequestIds = new Multimap();\n    /** @type {!Multimap<string, string>} */\n    this._requestHashToInterceptionIds = new Multimap();\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n    this._client.on('Network.requestIntercepted', this._onRequestIntercepted.bind(this));\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  /**\n   * @param {?{username: string, password: string}} credentials\n   */\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n\n  /**\n   * @param {!Object<string, string>} extraHTTPHeaders\n   */\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n    await this._client.send('Network.setExtraHTTPHeaders', { headers: this._extraHTTPHeaders });\n  }\n\n  /**\n   * @return {!Object<string, string>}\n   */\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  /**\n   * @param {boolean} value\n   */\n  async setOfflineMode(value) {\n    if (this._offline === value)\n      return;\n    this._offline = value;\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n\n  /**\n   * @param {string} userAgent\n   */\n  async setUserAgent(userAgent) {\n    await this._client.send('Network.setUserAgentOverride', { userAgent });\n  }\n\n  /**\n   * @param {boolean} value\n   */\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled)\n      return;\n    this._protocolRequestInterceptionEnabled = enabled;\n    const patterns = enabled ? [{urlPattern: '*'}] : [];\n    await Promise.all([\n      this._client.send('Network.setCacheDisabled', {cacheDisabled: enabled}),\n      this._client.send('Network.setRequestInterception', {patterns})\n    ]);\n  }\n\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   */\n  _onRequestWillBeSent(event) {\n    if (this._protocolRequestInterceptionEnabled) {\n      const requestHash = generateRequestHash(event.request);\n      const interceptionId = this._requestHashToInterceptionIds.firstValue(requestHash);\n      if (interceptionId) {\n        this._onRequest(event, interceptionId);\n        this._requestHashToInterceptionIds.delete(requestHash, interceptionId);\n      } else {\n        this._requestHashToRequestIds.set(requestHash, event.requestId);\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n      return;\n    }\n    this._onRequest(event, null);\n  }\n\n  /**\n   * @param {!Protocol.Network.requestInterceptedPayload} event\n   */\n  _onRequestIntercepted(event) {\n    if (event.authChallenge) {\n      /** @type {\"Default\"|\"CancelAuth\"|\"ProvideCredentials\"} */\n      let response = 'Default';\n      if (this._attemptedAuthentications.has(event.interceptionId)) {\n        response = 'CancelAuth';\n      } else if (this._credentials) {\n        response = 'ProvideCredentials';\n        this._attemptedAuthentications.add(event.interceptionId);\n      }\n      const {username, password} = this._credentials || {username: undefined, password: undefined};\n      this._client.send('Network.continueInterceptedRequest', {\n        interceptionId: event.interceptionId,\n        authChallengeResponse: { response, username, password }\n      }).catch(debugError);\n      return;\n    }\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Network.continueInterceptedRequest', {\n        interceptionId: event.interceptionId\n      }).catch(debugError);\n    }\n\n    const requestHash = generateRequestHash(event.request);\n    const requestId = this._requestHashToRequestIds.firstValue(requestHash);\n    if (requestId) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n      this._onRequest(requestWillBeSentEvent, event.interceptionId);\n      this._requestHashToRequestIds.delete(requestHash, requestId);\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestHashToInterceptionIds.set(requestHash, event.interceptionId);\n    }\n  }\n\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {?string} interceptionId\n   */\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId);\n      // If we connect late to the target, we could have missed the requestWillBeSent event.\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse.status, event.redirectResponse.headers, event.redirectResponse.fromDiskCache, event.redirectResponse.fromServiceWorker, event.redirectResponse.securityDetails);\n        redirectChain = request._redirectChain;\n      }\n    }\n    const isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';\n    this._handleRequestStart(event.requestId, interceptionId, event.request.url, isNavigationRequest, event.type, event.request, event.frameId, redirectChain);\n  }\n\n  /**\n   * @param {!Protocol.Network.requestServedFromCachePayload} event\n   */\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    if (request)\n      request._fromMemoryCache = true;\n  }\n\n  /**\n   * @param {!Request} request\n   * @param {number} redirectStatus\n   * @param {!Object} redirectHeaders\n   * @param {boolean} fromDiskCache\n   * @param {boolean} fromServiceWorker\n   * @param {?Object} securityDetails\n   */\n  _handleRequestRedirect(request, redirectStatus, redirectHeaders, fromDiskCache, fromServiceWorker, securityDetails) {\n    const response = new Response(this._client, request, redirectStatus, redirectHeaders, fromDiskCache, fromServiceWorker, securityDetails);\n    request._response = response;\n    request._redirectChain.push(request);\n    response._bodyLoadedPromiseFulfill.call(null, new Error('Response body is unavailable for redirect responses'));\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(NetworkManager.Events.Response, response);\n    this.emit(NetworkManager.Events.RequestFinished, request);\n  }\n\n  /**\n   * @param {string} requestId\n   * @param {?string} interceptionId\n   * @param {string} url\n   * @param {boolean} isNavigationRequest\n   * @param {string} resourceType\n   * @param {!Protocol.Network.Request} requestPayload\n   * @param {?string} frameId\n   * @param {!Array<!Request>} redirectChain\n   */\n  _handleRequestStart(requestId, interceptionId, url, isNavigationRequest, resourceType, requestPayload, frameId, redirectChain) {\n    let frame = null;\n    if (frameId)\n      frame = this._frameManager.frame(frameId);\n    const request = new Request(this._client, requestId, interceptionId, isNavigationRequest, this._userRequestInterceptionEnabled, url, resourceType, requestPayload, frame, redirectChain);\n    this._requestIdToRequest.set(requestId, request);\n    this.emit(NetworkManager.Events.Request, request);\n  }\n\n  /**\n   * @param {!Protocol.Network.responseReceivedPayload} event\n   */\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // FileUpload sends a response without a matching request.\n    if (!request)\n      return;\n    const response = new Response(this._client, request, event.response.status, event.response.headers,\n        event.response.fromDiskCache, event.response.fromServiceWorker, event.response.securityDetails);\n    request._response = response;\n    this.emit(NetworkManager.Events.Response, response);\n  }\n\n  /**\n   * @param {!Protocol.Network.loadingFinishedPayload} event\n   */\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n    request.response()._bodyLoadedPromiseFulfill.call(null);\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(NetworkManager.Events.RequestFinished, request);\n  }\n\n  /**\n   * @param {!Protocol.Network.loadingFailedPayload} event\n   */\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response)\n      response._bodyLoadedPromiseFulfill.call(null);\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(NetworkManager.Events.RequestFailed, request);\n  }\n}\n\nclass Request {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {?string} requestId\n   * @param {string} interceptionId\n   * @param {boolean} isNavigationRequest\n   * @param {boolean} allowInterception\n   * @param {string} url\n   * @param {string} resourceType\n   * @param {!Protocol.Network.Request} payload\n   * @param {?Puppeteer.Frame} frame\n   * @param {!Array<!Request>} redirectChain\n   */\n  constructor(client, requestId, interceptionId, isNavigationRequest, allowInterception, url, resourceType, payload, frame, redirectChain) {\n    this._client = client;\n    this._requestId = requestId;\n    this._isNavigationRequest = isNavigationRequest;\n    this._interceptionId = interceptionId;\n    this._allowInterception = allowInterception;\n    this._interceptionHandled = false;\n    this._response = null;\n    this._failureText = null;\n\n    this._url = url;\n    this._resourceType = resourceType.toLowerCase();\n    this._method = payload.method;\n    this._postData = payload.postData;\n    this._headers = {};\n    this._frame = frame;\n    this._redirectChain = redirectChain;\n    for (const key of Object.keys(payload.headers))\n      this._headers[key.toLowerCase()] = payload.headers[key];\n\n    this._fromMemoryCache = false;\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {string}\n   */\n  resourceType() {\n    return this._resourceType;\n  }\n\n  /**\n   * @return {string}\n   */\n  method() {\n    return this._method;\n  }\n\n  /**\n   * @return {string}\n   */\n  postData() {\n    return this._postData;\n  }\n\n  /**\n   * @return {!Object}\n   */\n  headers() {\n    return this._headers;\n  }\n\n  /**\n   * @return {?Response}\n   */\n  response() {\n    return this._response;\n  }\n\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n  frame() {\n    return this._frame;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isNavigationRequest() {\n    return this._isNavigationRequest;\n  }\n\n  /**\n   * @return {!Array<!Request>}\n   */\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n\n  /**\n   * @return {?{errorText: string}}\n   */\n  failure() {\n    if (!this._failureText)\n      return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n\n  /**\n   * @param {!Object=} overrides\n   */\n  async continue(overrides = {}) {\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      url: overrides.url,\n      method: overrides.method,\n      postData: overrides.postData,\n      headers: overrides.headers,\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response\n   */\n  async respond(response) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this._url.startsWith('data:'))\n      return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n\n    const responseBody = response.body && helper.isString(response.body) ? Buffer.from(/** @type {string} */(response.body)) : /** @type {?Buffer} */(response.body || null);\n\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers))\n        responseHeaders[header.toLowerCase()] = response.headers[header];\n    }\n    if (response.contentType)\n      responseHeaders['content-type'] = response.contentType;\n    if (responseBody && !('content-length' in responseHeaders)) {\n      // @ts-ignore\n      responseHeaders['content-length'] = Buffer.byteLength(responseBody);\n    }\n\n    const statusCode = response.status || 200;\n    const statusText = statusTexts[statusCode] || '';\n    const statusLine = `HTTP/1.1 ${statusCode} ${statusText}`;\n\n    const CRLF = '\\r\\n';\n    let text = statusLine + CRLF;\n    for (const header of Object.keys(responseHeaders))\n      text += header + ': ' + responseHeaders[header] + CRLF;\n    text += CRLF;\n    let responseBuffer = Buffer.from(text, 'utf8');\n    if (responseBody)\n      responseBuffer = Buffer.concat([responseBuffer, responseBody]);\n\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      rawResponse: responseBuffer.toString('base64')\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {string=} errorCode\n   */\n  async abort(errorCode = 'failed') {\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      errorReason\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n}\n\nconst errorReasons = {\n  'aborted': 'Aborted',\n  'accessdenied': 'AccessDenied',\n  'addressunreachable': 'AddressUnreachable',\n  'blockedbyclient': 'BlockedByClient',\n  'blockedbyresponse': 'BlockedByResponse',\n  'connectionaborted': 'ConnectionAborted',\n  'connectionclosed': 'ConnectionClosed',\n  'connectionfailed': 'ConnectionFailed',\n  'connectionrefused': 'ConnectionRefused',\n  'connectionreset': 'ConnectionReset',\n  'internetdisconnected': 'InternetDisconnected',\n  'namenotresolved': 'NameNotResolved',\n  'timedout': 'TimedOut',\n  'failed': 'Failed',\n};\n\nhelper.tracePublicAPI(Request);\n\nclass Response {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Request} request\n   * @param {number} status\n   * @param {!Object} headers\n   * @param {boolean} fromDiskCache\n   * @param {boolean} fromServiceWorker\n   * @param {?Object} securityDetails\n   */\n  constructor(client, request, status, headers, fromDiskCache, fromServiceWorker, securityDetails) {\n    this._client = client;\n    this._request = request;\n    this._contentPromise = null;\n\n    this._bodyLoadedPromise = new Promise(fulfill => {\n      this._bodyLoadedPromiseFulfill = fulfill;\n    });\n\n    this._status = status;\n    this._url = request.url();\n    this._fromDiskCache = fromDiskCache;\n    this._fromServiceWorker = fromServiceWorker;\n    this._headers = {};\n    for (const key of Object.keys(headers))\n      this._headers[key.toLowerCase()] = headers[key];\n    this._securityDetails = null;\n    if (securityDetails) {\n      this._securityDetails = new SecurityDetails(\n          securityDetails['subjectName'],\n          securityDetails['issuer'],\n          securityDetails['validFrom'],\n          securityDetails['validTo'],\n          securityDetails['protocol']);\n    }\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  ok() {\n    return this._status === 0 || (this._status >= 200 && this._status <= 299);\n  }\n\n  /**\n   * @return {number}\n   */\n  status() {\n    return this._status;\n  }\n\n  /**\n   * @return {!Object}\n   */\n  headers() {\n    return this._headers;\n  }\n\n  /**\n   * @return {?SecurityDetails}\n   */\n  securityDetails() {\n    return this._securityDetails;\n  }\n\n  /**\n   * @return {!Promise<!Buffer>}\n   */\n  buffer() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._bodyLoadedPromise.then(async error => {\n        if (error)\n          throw error;\n        const response = await this._client.send('Network.getResponseBody', {\n          requestId: this._request._requestId\n        });\n        return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n      });\n    }\n    return this._contentPromise;\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n\n  /**\n   * @return {!Promise<!Object>}\n   */\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n\n  /**\n   * @return {!Request}\n   */\n  request() {\n    return this._request;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  fromCache() {\n    return this._fromDiskCache || this._request._fromMemoryCache;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n}\nhelper.tracePublicAPI(Response);\n\n/**\n * @param {!Protocol.Network.Request} request\n * @return {string}\n */\nfunction generateRequestHash(request) {\n  let normalizedURL = request.url;\n  try {\n    // Decoding is necessary to normalize URLs. @see crbug.com/759388\n    // The method will throw if the URL is malformed. In this case,\n    // consider URL to be normalized as-is.\n    normalizedURL = decodeURI(request.url);\n  } catch (e) {\n  }\n  const hash = {\n    url: normalizedURL,\n    method: request.method,\n    postData: request.postData,\n    headers: {},\n  };\n\n  if (!normalizedURL.startsWith('data:')) {\n    const headers = Object.keys(request.headers);\n    headers.sort();\n    for (let header of headers) {\n      const headerValue = request.headers[header];\n      header = header.toLowerCase();\n      if (header === 'accept' || header === 'referer' || header === 'x-devtools-emulate-network-conditions-client-id' || header === 'cookie')\n        continue;\n      hash.headers[header] = headerValue;\n    }\n  }\n  return JSON.stringify(hash);\n}\n\nclass SecurityDetails {\n  /**\n   * @param {string} subjectName\n   * @param {string} issuer\n   * @param {number} validFrom\n   * @param {number} validTo\n   * @param {string} protocol\n   */\n\n  constructor(subjectName, issuer, validFrom, validTo, protocol) {\n    this._subjectName = subjectName;\n    this._issuer = issuer;\n    this._validFrom = validFrom;\n    this._validTo = validTo;\n    this._protocol = protocol;\n  }\n\n  /**\n   * @return {string}\n   */\n  subjectName() {\n    return this._subjectName;\n  }\n\n  /**\n   * @return {string}\n   */\n  issuer() {\n    return this._issuer;\n  }\n\n  /**\n   * @return {number}\n   */\n  validFrom() {\n    return this._validFrom;\n  }\n\n  /**\n   * @return {number}\n   */\n  validTo() {\n    return this._validTo;\n  }\n\n  /**\n   * @return {string}\n   */\n  protocol() {\n    return this._protocol;\n  }\n}\n\nNetworkManager.Events = {\n  Request: 'request',\n  Response: 'response',\n  RequestFailed: 'requestfailed',\n  RequestFinished: 'requestfinished',\n};\n\nconst statusTexts = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '209': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': 'I\\'m a teapot',\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required',\n};\n\nmodule.exports = {Request, Response, NetworkManager};\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst fs = require('fs');\nconst EventEmitter = require('events');\nconst mime = require('mime');\nconst {NetworkManager} = require('./NetworkManager');\nconst {NavigatorWatcher} = require('./NavigatorWatcher');\nconst {Dialog} = require('./Dialog');\nconst {EmulationManager} = require('./EmulationManager');\nconst {FrameManager} = require('./FrameManager');\nconst {Keyboard, Mouse, Touchscreen} = require('./Input');\nconst Tracing = require('./Tracing');\nconst {helper, debugError, assert} = require('./helper');\nconst {Coverage} = require('./Coverage');\nconst {Worker} = require('./Worker');\n\nconst writeFileAsync = helper.promisify(fs.writeFile);\n\nclass Page extends EventEmitter {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Puppeteer.Target} target\n   * @param {boolean} ignoreHTTPSErrors\n   * @param {?Puppeteer.Viewport} defaultViewport\n   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue\n   * @return {!Promise<!Page>}\n   */\n  static async create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {\n\n    await client.send('Page.enable');\n    const {frameTree} = await client.send('Page.getFrameTree');\n    const page = new Page(client, target, frameTree, ignoreHTTPSErrors, screenshotTaskQueue);\n\n    await Promise.all([\n      client.send('Target.setAutoAttach', {autoAttach: true, waitForDebuggerOnStart: false}),\n      client.send('Page.setLifecycleEventsEnabled', { enabled: true }),\n      client.send('Network.enable', {}),\n      client.send('Runtime.enable', {}),\n      client.send('Security.enable', {}),\n      client.send('Performance.enable', {}),\n      client.send('Log.enable', {}),\n    ]);\n    if (ignoreHTTPSErrors)\n      await client.send('Security.setOverrideCertificateErrors', {override: true});\n    // Initialize default page size.\n    if (defaultViewport)\n      await page.setViewport(defaultViewport);\n\n    return page;\n  }\n\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Puppeteer.Target} target\n   * @param {!Protocol.Page.FrameTree} frameTree\n   * @param {boolean} ignoreHTTPSErrors\n   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue\n   */\n  constructor(client, target, frameTree, ignoreHTTPSErrors, screenshotTaskQueue) {\n    super();\n    this._closed = false;\n    this._client = client;\n    this._target = target;\n    this._keyboard = new Keyboard(client);\n    this._mouse = new Mouse(client, this._keyboard);\n    this._touchscreen = new Touchscreen(client, this._keyboard);\n    /** @type {!FrameManager} */\n    this._frameManager = new FrameManager(client, frameTree, this);\n    this._networkManager = new NetworkManager(client, this._frameManager);\n    this._emulationManager = new EmulationManager(client);\n    this._tracing = new Tracing(client);\n    /** @type {!Map<string, Function>} */\n    this._pageBindings = new Map();\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._coverage = new Coverage(client);\n    this._defaultNavigationTimeout = 30000;\n    this._javascriptEnabled = true;\n    /** @type {?Puppeteer.Viewport} */\n    this._viewport = null;\n\n    this._screenshotTaskQueue = screenshotTaskQueue;\n\n    /** @type {!Map<string, Worker>} */\n    this._workers = new Map();\n    client.on('Target.attachedToTarget', event => {\n      if (event.targetInfo.type !== 'worker') {\n        // If we don't detach from service workers, they will never die.\n        client.send('Target.detachFromTarget', {\n          sessionId: event.sessionId\n        }).catch(debugError);\n        return;\n      }\n      const session = client._createSession(event.targetInfo.type, event.sessionId);\n      const worker = new Worker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this));\n      this._workers.set(event.sessionId, worker);\n      this.emit(Page.Events.WorkerCreated, worker);\n\n    });\n    client.on('Target.detachedFromTarget', event => {\n      const worker = this._workers.get(event.sessionId);\n      if (!worker)\n        return;\n      this.emit(Page.Events.WorkerDestroyed, worker);\n      this._workers.delete(event.sessionId);\n    });\n\n    this._frameManager.on(FrameManager.Events.FrameAttached, event => this.emit(Page.Events.FrameAttached, event));\n    this._frameManager.on(FrameManager.Events.FrameDetached, event => this.emit(Page.Events.FrameDetached, event));\n    this._frameManager.on(FrameManager.Events.FrameNavigated, event => this.emit(Page.Events.FrameNavigated, event));\n\n    this._networkManager.on(NetworkManager.Events.Request, event => this.emit(Page.Events.Request, event));\n    this._networkManager.on(NetworkManager.Events.Response, event => this.emit(Page.Events.Response, event));\n    this._networkManager.on(NetworkManager.Events.RequestFailed, event => this.emit(Page.Events.RequestFailed, event));\n    this._networkManager.on(NetworkManager.Events.RequestFinished, event => this.emit(Page.Events.RequestFinished, event));\n\n    client.on('Page.domContentEventFired', event => this.emit(Page.Events.DOMContentLoaded));\n    client.on('Page.loadEventFired', event => this.emit(Page.Events.Load));\n    client.on('Runtime.consoleAPICalled', event => this._onConsoleAPI(event));\n    client.on('Runtime.bindingCalled', event => this._onBindingCalled(event));\n    client.on('Page.javascriptDialogOpening', event => this._onDialog(event));\n    client.on('Runtime.exceptionThrown', exception => this._handleException(exception.exceptionDetails));\n    client.on('Security.certificateError', event => this._onCertificateError(event));\n    client.on('Inspector.targetCrashed', event => this._onTargetCrashed());\n    client.on('Performance.metrics', event => this._emitMetrics(event));\n    client.on('Log.entryAdded', event => this._onLogEntryAdded(event));\n    this._target._isClosedPromise.then(() => {\n      this.emit(Page.Events.Close);\n      this._closed = true;\n    });\n  }\n\n  /**\n   * @return {!Puppeteer.Target}\n   */\n  target() {\n    return this._target;\n  }\n\n  /**\n   * @return {!Puppeteer.Browser}\n   */\n  browser() {\n    return this._target.browser();\n  }\n\n  _onTargetCrashed() {\n    this.emit('error', new Error('Page crashed!'));\n  }\n\n  /**\n   * @param {!Protocol.Log.entryAddedPayload} event\n   */\n  _onLogEntryAdded(event) {\n    const {level, text, args, source} = event.entry;\n    if (args)\n      args.map(arg => helper.releaseObject(this._client, arg));\n    if (source !== 'worker')\n      this.emit(Page.Events.Console, new ConsoleMessage(level, text));\n  }\n\n  /**\n   * @return {!Puppeteer.Frame}\n   */\n  mainFrame() {\n    return this._frameManager.mainFrame();\n  }\n\n  /**\n   * @return {!Keyboard}\n   */\n  get keyboard() {\n    return this._keyboard;\n  }\n\n  /**\n   * @return {!Touchscreen}\n   */\n  get touchscreen() {\n    return this._touchscreen;\n  }\n\n  /**\n   * @return {!Coverage}\n   */\n  get coverage() {\n    return this._coverage;\n  }\n\n  /**\n   * @return {!Tracing}\n   */\n  get tracing() {\n    return this._tracing;\n  }\n\n  /**\n   * @return {!Array<Puppeteer.Frame>}\n   */\n  frames() {\n    return this._frameManager.frames();\n  }\n\n  /**\n   * @return {!Array<!Worker>}\n   */\n  workers() {\n    return Array.from(this._workers.values());\n  }\n\n  /**\n   * @param {boolean} value\n   */\n  async setRequestInterception(value) {\n    return this._networkManager.setRequestInterception(value);\n  }\n\n  /**\n   * @param {boolean} enabled\n   */\n  setOfflineMode(enabled) {\n    return this._networkManager.setOfflineMode(enabled);\n  }\n\n  /**\n   * @param {number} timeout\n   */\n  setDefaultNavigationTimeout(timeout) {\n    this._defaultNavigationTimeout = timeout;\n  }\n\n  /**\n   * @param {!Protocol.Security.certificateErrorPayload} event\n   */\n  _onCertificateError(event) {\n    if (!this._ignoreHTTPSErrors)\n      return;\n    this._client.send('Security.handleCertificateError', {\n      eventId: event.eventId,\n      action: 'continue'\n    }).catch(debugError);\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n  async $(selector) {\n    return this.mainFrame().$(selector);\n  }\n\n  /**\n   * @param {function()|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<!Puppeteer.JSHandle>}\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    const context = await this.mainFrame().executionContext();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @param {!Puppeteer.JSHandle} prototypeHandle\n   * @return {!Promise<!Puppeteer.JSHandle>}\n   */\n  async queryObjects(prototypeHandle) {\n    const context = await this.mainFrame().executionContext();\n    return context.queryObjects(prototypeHandle);\n  }\n\n  /**\n   * @param {string} selector\n   * @param {function()|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $eval(selector, pageFunction, ...args) {\n    return this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * @param {string} selector\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $$eval(selector, pageFunction, ...args) {\n    return this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<!Array<!Puppeteer.ElementHandle>>}\n   */\n  async $$(selector) {\n    return this.mainFrame().$$(selector);\n  }\n\n  /**\n   * @param {string} expression\n   * @return {!Promise<!Array<!Puppeteer.ElementHandle>>}\n   */\n  async $x(expression) {\n    return this.mainFrame().$x(expression);\n  }\n\n  /**\n   * @param {!Array<string>} urls\n   * @return {!Promise<!Array<Network.Cookie>>}\n   */\n  async cookies(...urls) {\n    return (await this._client.send('Network.getCookies', {\n      urls: urls.length ? urls : [this.url()]\n    })).cookies;\n  }\n\n  /**\n   * @param {Array<Network.CookieParam>} cookies\n   */\n  async deleteCookie(...cookies) {\n    const pageURL = this.url();\n    for (const cookie of cookies) {\n      const item = Object.assign({}, cookie);\n      if (!cookie.url && pageURL.startsWith('http'))\n        item.url = pageURL;\n      await this._client.send('Network.deleteCookies', item);\n    }\n  }\n\n  /**\n   * @param {Array<Network.CookieParam>} cookies\n   */\n  async setCookie(...cookies) {\n    const pageURL = this.url();\n    const startsWithHTTP = pageURL.startsWith('http');\n    const items = cookies.map(cookie => {\n      const item = Object.assign({}, cookie);\n      if (!item.url && startsWithHTTP)\n        item.url = pageURL;\n      assert(\n          item.url !== 'about:blank',\n          `Blank page can not have cookie \"${item.name}\"`\n      );\n      assert(\n          !String.prototype.startsWith.call(item.url || '', 'data:'),\n          `Data URL page can not have cookie \"${item.name}\"`\n      );\n      return item;\n    });\n    await this.deleteCookie(...items);\n    if (items.length)\n      await this._client.send('Network.setCookies', { cookies: items });\n  }\n\n  /**\n   * @param {Object} options\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n  async addScriptTag(options) {\n    return this.mainFrame().addScriptTag(options);\n  }\n\n  /**\n   * @param {Object} options\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n  async addStyleTag(options) {\n    return this.mainFrame().addStyleTag(options);\n  }\n\n  /**\n   * @param {string} name\n   * @param {function(?)} puppeteerFunction\n   */\n  async exposeFunction(name, puppeteerFunction) {\n    if (this._pageBindings.has(name))\n      throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);\n    this._pageBindings.set(name, puppeteerFunction);\n\n    const expression = helper.evaluationString(addPageBinding, name);\n    await this._client.send('Runtime.addBinding', {name: name});\n    await this._client.send('Page.addScriptToEvaluateOnNewDocument', {source: expression});\n    await Promise.all(this.frames().map(frame => frame.evaluate(expression).catch(debugError)));\n\n    function addPageBinding(bindingName) {\n      const binding = window[bindingName];\n      window[bindingName] = async(...args) => {\n        const me = window[bindingName];\n        let callbacks = me['callbacks'];\n        if (!callbacks) {\n          callbacks = new Map();\n          me['callbacks'] = callbacks;\n        }\n        const seq = (me['lastSeq'] || 0) + 1;\n        me['lastSeq'] = seq;\n        const promise = new Promise(fulfill => callbacks.set(seq, fulfill));\n        binding(JSON.stringify({name: bindingName, seq, args}));\n        return promise;\n      };\n    }\n  }\n\n  /**\n   * @param {?{username: string, password: string}} credentials\n   */\n  async authenticate(credentials) {\n    return this._networkManager.authenticate(credentials);\n  }\n\n  /**\n   * @param {!Object<string, string>} headers\n   */\n  async setExtraHTTPHeaders(headers) {\n    return this._networkManager.setExtraHTTPHeaders(headers);\n  }\n\n  /**\n   * @param {string} userAgent\n   */\n  async setUserAgent(userAgent) {\n    return this._networkManager.setUserAgent(userAgent);\n  }\n\n  /**\n   * @return {!Promise<!Object>}\n   */\n  async metrics() {\n    const response = await this._client.send('Performance.getMetrics');\n    return this._buildMetricsObject(response.metrics);\n  }\n\n  /**\n   * @param {*} event\n   */\n  _emitMetrics(event) {\n    this.emit(Page.Events.Metrics, {\n      title: event.title,\n      metrics: this._buildMetricsObject(event.metrics)\n    });\n  }\n\n  /**\n   * @param {?Array<!Protocol.Performance.Metric>} metrics\n   * @return {!Object}\n   */\n  _buildMetricsObject(metrics) {\n    const result = {};\n    for (const metric of metrics || []) {\n      if (supportedMetrics.has(metric.name))\n        result[metric.name] = metric.value;\n    }\n    return result;\n  }\n\n  /**\n   * @param {!Protocol.Runtime.ExceptionDetails} exceptionDetails\n   */\n  _handleException(exceptionDetails) {\n    const message = helper.getExceptionMessage(exceptionDetails);\n    const err = new Error(message);\n    err.stack = ''; // Don't report clientside error with a node stack attached\n    this.emit(Page.Events.PageError, err);\n  }\n\n  /**\n   * @param {!Protocol.Runtime.consoleAPICalledPayload} event\n   */\n  async _onConsoleAPI(event) {\n    const context = this._frameManager.executionContextById(event.executionContextId);\n    const values = event.args.map(arg => this._frameManager.createJSHandle(context, arg));\n    this._addConsoleMessage(event.type, values);\n  }\n\n  /**\n   * @param {!Protocol.Runtime.bindingCalledPayload} event\n   */\n  async _onBindingCalled(event) {\n    const {name, seq, args} = JSON.parse(event.payload);\n    const result = await this._pageBindings.get(name)(...args);\n    const expression = helper.evaluationString(deliverResult, name, seq, result);\n    this._client.send('Runtime.evaluate', { expression, contextId: event.executionContextId }).catch(debugError);\n\n    function deliverResult(name, seq, result) {\n      window[name]['callbacks'].get(seq)(result);\n      window[name]['callbacks'].delete(seq);\n    }\n  }\n\n  /**\n   * @param {string} type\n   * @param {!Array<!Puppeteer.JSHandle>} args\n   */\n  _addConsoleMessage(type, args) {\n    if (!this.listenerCount(Page.Events.Console)) {\n      args.forEach(arg => arg.dispose());\n      return;\n    }\n    const textTokens = [];\n    for (const arg of args) {\n      const remoteObject = arg._remoteObject;\n      if (remoteObject.objectId)\n        textTokens.push(arg.toString());\n      else\n        textTokens.push(helper.valueFromRemoteObject(remoteObject));\n    }\n    const message = new ConsoleMessage(type, textTokens.join(' '), args);\n    this.emit(Page.Events.Console, message);\n  }\n\n  _onDialog(event) {\n    let dialogType = null;\n    if (event.type === 'alert')\n      dialogType = Dialog.Type.Alert;\n    else if (event.type === 'confirm')\n      dialogType = Dialog.Type.Confirm;\n    else if (event.type === 'prompt')\n      dialogType = Dialog.Type.Prompt;\n    else if (event.type === 'beforeunload')\n      dialogType = Dialog.Type.BeforeUnload;\n    assert(dialogType, 'Unknown javascript dialog type: ' + event.type);\n    const dialog = new Dialog(this._client, dialogType, event.message, event.defaultPrompt);\n    this.emit(Page.Events.Dialog, dialog);\n  }\n\n  /**\n   * @return {!string}\n   */\n  url() {\n    return this.mainFrame().url();\n  }\n\n  /**\n   * @return {!Promise<String>}\n   */\n  async content() {\n    return await this._frameManager.mainFrame().content();\n  }\n\n  /**\n   * @param {string} html\n   */\n  async setContent(html) {\n    await this._frameManager.mainFrame().setContent(html);\n  }\n\n  /**\n   * @param {string} url\n   * @param {!Object=} options\n   * @return {!Promise<?Puppeteer.Response>}\n   */\n  async goto(url, options = {}) {\n    const referrer = this._networkManager.extraHTTPHeaders()['referer'];\n\n    /** @type {Map<string, !Puppeteer.Request>} */\n    const requests = new Map();\n    const eventListeners = [\n      helper.addEventListener(this._networkManager, NetworkManager.Events.Request, request => {\n        if (!requests.get(request.url()))\n          requests.set(request.url(), request);\n      })\n    ];\n\n    const mainFrame = this._frameManager.mainFrame();\n    const timeout = typeof options.timeout === 'number' ? options.timeout : this._defaultNavigationTimeout;\n    const watcher = new NavigatorWatcher(this._frameManager, mainFrame, timeout, options);\n    const navigationPromise = watcher.navigationPromise();\n    let error = await Promise.race([\n      navigate(this._client, url, referrer),\n      navigationPromise,\n    ]);\n    if (!error)\n      error = await navigationPromise;\n    watcher.cancel();\n    helper.removeEventListeners(eventListeners);\n    if (error)\n      throw error;\n    const request = requests.get(mainFrame._navigationURL);\n    return request ? request.response() : null;\n\n    /**\n     * @param {!Puppeteer.CDPSession} client\n     * @param {string} url\n     * @param {string} referrer\n     * @return {!Promise<?Error>}\n     */\n    async function navigate(client, url, referrer) {\n      try {\n        const response = await client.send('Page.navigate', {url, referrer});\n        return response.errorText ? new Error(`${response.errorText} at ${url}`) : null;\n      } catch (error) {\n        return error;\n      }\n    }\n  }\n\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<?Puppeteer.Response>}\n   */\n  async reload(options) {\n    const [response] = await Promise.all([\n      this.waitForNavigation(options),\n      this._client.send('Page.reload')\n    ]);\n    return response;\n  }\n\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<?Puppeteer.Response>}\n   */\n  async waitForNavigation(options = {}) {\n    const mainFrame = this._frameManager.mainFrame();\n    const timeout = typeof options.timeout === 'number' ? options.timeout : this._defaultNavigationTimeout;\n    const watcher = new NavigatorWatcher(this._frameManager, mainFrame, timeout, options);\n\n    const responses = new Map();\n    const listener = helper.addEventListener(this._networkManager, NetworkManager.Events.Response, response => responses.set(response.url(), response));\n    const error = await watcher.navigationPromise();\n    helper.removeEventListeners([listener]);\n    if (error)\n      throw error;\n    return responses.get(this.mainFrame().url()) || null;\n  }\n\n  /**\n   * @param {(string|Function)} urlOrPredicate\n   * @param {!Object=} options\n   * @return {!Promise<!Puppeteer.Request>}\n   */\n  async waitForRequest(urlOrPredicate, options = {}) {\n    const timeout = typeof options.timeout === 'number' ? options.timeout : 30000;\n    return helper.waitForEvent(this._networkManager, NetworkManager.Events.Request, request => {\n      if (helper.isString(urlOrPredicate))\n        return (urlOrPredicate === request.url());\n      if (typeof urlOrPredicate === 'function')\n        return !!(urlOrPredicate(request));\n      return false;\n    }, timeout);\n  }\n\n  /**\n   * @param {(string|Function)} urlOrPredicate\n   * @param {!Object=} options\n   * @return {!Promise<!Puppeteer.Response>}\n   */\n  async waitForResponse(urlOrPredicate, options = {}) {\n    const timeout = typeof options.timeout === 'number' ? options.timeout : 30000;\n    return helper.waitForEvent(this._networkManager, NetworkManager.Events.Response, response => {\n      if (helper.isString(urlOrPredicate))\n        return (urlOrPredicate === response.url());\n      if (typeof urlOrPredicate === 'function')\n        return !!(urlOrPredicate(response));\n      return false;\n    }, timeout);\n  }\n\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<?Puppeteer.Response>}\n   */\n  async goBack(options) {\n    return this._go(-1, options);\n  }\n\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<?Puppeteer.Response>}\n   */\n  async goForward(options) {\n    return this._go(+1, options);\n  }\n\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<?Puppeteer.Response>}\n   */\n  async _go(delta, options) {\n    const history = await this._client.send('Page.getNavigationHistory');\n    const entry = history.entries[history.currentIndex + delta];\n    if (!entry)\n      return null;\n    const [response] = await Promise.all([\n      this.waitForNavigation(options),\n      this._client.send('Page.navigateToHistoryEntry', {entryId: entry.id}),\n    ]);\n    return response;\n  }\n\n  async bringToFront() {\n    await this._client.send('Page.bringToFront');\n  }\n\n  /**\n   * @param {!Object} options\n   */\n  async emulate(options) {\n    return Promise.all([\n      this.setViewport(options.viewport),\n      this.setUserAgent(options.userAgent)\n    ]);\n  }\n\n  /**\n   * @param {boolean} enabled\n   */\n  async setJavaScriptEnabled(enabled) {\n    if (this._javascriptEnabled === enabled)\n      return;\n    this._javascriptEnabled = enabled;\n    await this._client.send('Emulation.setScriptExecutionDisabled', { value: !enabled });\n  }\n\n  /**\n   * @param {boolean} enabled\n   */\n  async setBypassCSP(enabled) {\n    await this._client.send('Page.setBypassCSP', { enabled });\n  }\n\n  /**\n   * @param {?string} mediaType\n   */\n  async emulateMedia(mediaType) {\n    assert(mediaType === 'screen' || mediaType === 'print' || mediaType === null, 'Unsupported media type: ' + mediaType);\n    await this._client.send('Emulation.setEmulatedMedia', {media: mediaType || ''});\n  }\n\n  /**\n   * @param {!Puppeteer.Viewport} viewport\n   */\n  async setViewport(viewport) {\n    const needsReload = await this._emulationManager.emulateViewport(viewport);\n    this._viewport = viewport;\n    if (needsReload)\n      await this.reload();\n  }\n\n  /**\n   * @return {?Puppeteer.Viewport}\n   */\n  viewport() {\n    return this._viewport;\n  }\n\n  /**\n   * @param {function()|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<*>}\n   */\n  async evaluate(pageFunction, ...args) {\n    return this._frameManager.mainFrame().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @param {function()|string} pageFunction\n   * @param {!Array<*>} args\n   */\n  async evaluateOnNewDocument(pageFunction, ...args) {\n    const source = helper.evaluationString(pageFunction, ...args);\n    await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source });\n  }\n\n  /**\n   * @param {Boolean} enabled\n   * @returns {!Promise}\n   */\n  async setCacheEnabled(enabled = true) {\n    await this._client.send('Network.setCacheDisabled', {cacheDisabled: !enabled});\n  }\n\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<!Buffer|!String>}\n   */\n  async screenshot(options = {}) {\n    let screenshotType = null;\n    // options.type takes precedence over inferring the type from options.path\n    // because it may be a 0-length file with no extension created beforehand (i.e. as a temp file).\n    if (options.type) {\n      assert(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);\n      screenshotType = options.type;\n    } else if (options.path) {\n      const mimeType = mime.getType(options.path);\n      if (mimeType === 'image/png')\n        screenshotType = 'png';\n      else if (mimeType === 'image/jpeg')\n        screenshotType = 'jpeg';\n      assert(screenshotType, 'Unsupported screenshot mime type: ' + mimeType);\n    }\n\n    if (!screenshotType)\n      screenshotType = 'png';\n\n    if (options.quality) {\n      assert(screenshotType === 'jpeg', 'options.quality is unsupported for the ' + screenshotType + ' screenshots');\n      assert(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' + (typeof options.quality));\n      assert(Number.isInteger(options.quality), 'Expected options.quality to be an integer');\n      assert(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' + options.quality);\n    }\n    assert(!options.clip || !options.fullPage, 'options.clip and options.fullPage are exclusive');\n    if (options.clip) {\n      assert(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' + (typeof options.clip.x));\n      assert(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' + (typeof options.clip.y));\n      assert(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' + (typeof options.clip.width));\n      assert(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' + (typeof options.clip.height));\n    }\n    return this._screenshotTaskQueue.postTask(this._screenshotTask.bind(this, screenshotType, options));\n  }\n\n  /**\n   * @param {\"png\"|\"jpeg\"} format\n   * @param {!Object=} options\n   * @return {!Promise<!Buffer|!String>}\n   */\n  async _screenshotTask(format, options) {\n    await this._client.send('Target.activateTarget', {targetId: this._target._targetId});\n    let clip = options.clip ? Object.assign({}, options['clip']) : undefined;\n    if (clip)\n      clip.scale = 1;\n\n    if (options.fullPage) {\n      const metrics = await this._client.send('Page.getLayoutMetrics');\n      const width = Math.ceil(metrics.contentSize.width);\n      const height = Math.ceil(metrics.contentSize.height);\n\n      // Overwrite clip for full page at all times.\n      clip = { x: 0, y: 0, width, height, scale: 1 };\n      const mobile = this._viewport.isMobile || false;\n      const deviceScaleFactor = this._viewport.deviceScaleFactor || 1;\n      const landscape = this._viewport.isLandscape || false;\n      /** @type {!Protocol.Emulation.ScreenOrientation} */\n      const screenOrientation = landscape ? { angle: 90, type: 'landscapePrimary' } : { angle: 0, type: 'portraitPrimary' };\n      await this._client.send('Emulation.setDeviceMetricsOverride', { mobile, width, height, deviceScaleFactor, screenOrientation });\n    }\n\n    if (options.omitBackground)\n      await this._client.send('Emulation.setDefaultBackgroundColorOverride', { color: { r: 0, g: 0, b: 0, a: 0 } });\n    const result = await this._client.send('Page.captureScreenshot', { format, quality: options.quality, clip });\n    if (options.omitBackground)\n      await this._client.send('Emulation.setDefaultBackgroundColorOverride');\n\n    if (options.fullPage)\n      await this.setViewport(this._viewport);\n\n    const buffer = options.encoding === 'base64' ? result.data : Buffer.from(result.data, 'base64');\n    if (options.path)\n      await writeFileAsync(options.path, buffer);\n    return buffer;\n  }\n\n  /**\n   * @param {!Object=} options\n   * @return {!Promise<!Buffer>}\n   */\n  async pdf(options = {}) {\n    const scale = options.scale || 1;\n    const displayHeaderFooter = !!options.displayHeaderFooter;\n    const headerTemplate = options.headerTemplate || '';\n    const footerTemplate = options.footerTemplate || '';\n    const printBackground = !!options.printBackground;\n    const landscape = !!options.landscape;\n    const pageRanges = options.pageRanges || '';\n\n    let paperWidth = 8.5;\n    let paperHeight = 11;\n    if (options.format) {\n      const format = Page.PaperFormats[options.format.toLowerCase()];\n      assert(format, 'Unknown paper format: ' + options.format);\n      paperWidth = format.width;\n      paperHeight = format.height;\n    } else {\n      paperWidth = convertPrintParameterToInches(options.width) || paperWidth;\n      paperHeight = convertPrintParameterToInches(options.height) || paperHeight;\n    }\n\n    const marginOptions = options.margin || {};\n    const marginTop = convertPrintParameterToInches(marginOptions.top) || 0;\n    const marginLeft = convertPrintParameterToInches(marginOptions.left) || 0;\n    const marginBottom = convertPrintParameterToInches(marginOptions.bottom) || 0;\n    const marginRight = convertPrintParameterToInches(marginOptions.right) || 0;\n    const preferCSSPageSize = options.preferCSSPageSize || false;\n\n    const result = await this._client.send('Page.printToPDF', {\n      landscape: landscape,\n      displayHeaderFooter: displayHeaderFooter,\n      headerTemplate: headerTemplate,\n      footerTemplate: footerTemplate,\n      printBackground: printBackground,\n      scale: scale,\n      paperWidth: paperWidth,\n      paperHeight: paperHeight,\n      marginTop: marginTop,\n      marginBottom: marginBottom,\n      marginLeft: marginLeft,\n      marginRight: marginRight,\n      pageRanges: pageRanges,\n      preferCSSPageSize: preferCSSPageSize\n    });\n    const buffer = Buffer.from(result.data, 'base64');\n    if (options.path)\n      await writeFileAsync(options.path, buffer);\n    return buffer;\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async title() {\n    return this.mainFrame().title();\n  }\n\n  /**\n   * @param {!{runBeforeUnload: (boolean|undefined)}=} options\n   */\n  async close(options = {runBeforeUnload: undefined}) {\n    assert(!!this._client._connection, 'Protocol error: Connection closed. Most likely the page has been closed.');\n    const runBeforeUnload = !!options.runBeforeUnload;\n    if (runBeforeUnload) {\n      await this._client.send('Page.close');\n    } else {\n      await this._client._connection.send('Target.closeTarget', { targetId: this._target._targetId });\n      await this._target._isClosedPromise;\n    }\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isClosed() {\n    return this._closed;\n  }\n\n  /**\n   * @return {!Mouse}\n   */\n  get mouse() {\n    return this._mouse;\n  }\n\n  /**\n   * @param {string} selector\n   * @param {!Object=} options\n   */\n  click(selector, options = {}) {\n    return this.mainFrame().click(selector, options);\n  }\n\n  /**\n   * @param {string} selector\n   */\n  focus(selector) {\n    return this.mainFrame().focus(selector);\n  }\n\n  /**\n   * @param {string} selector\n   */\n  hover(selector) {\n    return this.mainFrame().hover(selector);\n  }\n\n  /**\n   * @param {string} selector\n   * @param {!Array<string>} values\n   * @return {!Promise<!Array<string>>}\n   */\n  select(selector, ...values) {\n    return this.mainFrame().select(selector, ...values);\n  }\n\n  /**\n   * @param {string} selector\n   */\n  tap(selector) {\n    return this.mainFrame().tap(selector);\n  }\n\n  /**\n   * @param {string} selector\n   * @param {string} text\n   * @param {{delay: (number|undefined)}=} options\n   */\n  type(selector, text, options) {\n    return this.mainFrame().type(selector, text, options);\n  }\n\n  /**\n   * @param {(string|number|Function)} selectorOrFunctionOrTimeout\n   * @param {!Object=} options\n   * @param {!Array<*>} args\n   * @return {!Promise}\n   */\n  waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n    return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);\n  }\n\n  /**\n   * @param {string} selector\n   * @param {!Object=} options\n   * @return {!Promise}\n   */\n  waitForSelector(selector, options = {}) {\n    return this.mainFrame().waitForSelector(selector, options);\n  }\n\n  /**\n   * @param {string} xpath\n   * @param {!Object=} options\n   * @return {!Promise}\n   */\n  waitForXPath(xpath, options = {}) {\n    return this.mainFrame().waitForXPath(xpath, options);\n  }\n\n  /**\n   * @param {function()} pageFunction\n   * @param {!Object=} options\n   * @param {!Array<*>} args\n   * @return {!Promise}\n   */\n  waitForFunction(pageFunction, options = {}, ...args) {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n}\n\n/** @type {!Set<string>} */\nconst supportedMetrics = new Set([\n  'Timestamp',\n  'Documents',\n  'Frames',\n  'JSEventListeners',\n  'Nodes',\n  'LayoutCount',\n  'RecalcStyleCount',\n  'LayoutDuration',\n  'RecalcStyleDuration',\n  'ScriptDuration',\n  'TaskDuration',\n  'JSHeapUsedSize',\n  'JSHeapTotalSize',\n]);\n\n/** @enum {string} */\nPage.PaperFormats = {\n  letter: {width: 8.5, height: 11},\n  legal: {width: 8.5, height: 14},\n  tabloid: {width: 11, height: 17},\n  ledger: {width: 17, height: 11},\n  a0: {width: 33.1, height: 46.8 },\n  a1: {width: 23.4, height: 33.1 },\n  a2: {width: 16.5, height: 23.4 },\n  a3: {width: 11.7, height: 16.5 },\n  a4: {width: 8.27, height: 11.7 },\n  a5: {width: 5.83, height: 8.27 },\n  a6: {width: 4.13, height: 5.83 },\n};\n\nconst unitToPixels = {\n  'px': 1,\n  'in': 96,\n  'cm': 37.8,\n  'mm': 3.78\n};\n\n/**\n * @param {(string|number|undefined)} parameter\n * @return {(number|undefined)}\n */\nfunction convertPrintParameterToInches(parameter) {\n  if (typeof parameter === 'undefined')\n    return undefined;\n  let pixels;\n  if (helper.isNumber(parameter)) {\n    // Treat numbers as pixel values to be aligned with phantom's paperSize.\n    pixels = /** @type {number} */ (parameter);\n  } else if (helper.isString(parameter)) {\n    const text = /** @type {string} */ (parameter);\n    let unit = text.substring(text.length - 2).toLowerCase();\n    let valueText = '';\n    if (unitToPixels.hasOwnProperty(unit)) {\n      valueText = text.substring(0, text.length - 2);\n    } else {\n      // In case of unknown unit try to parse the whole parameter as number of pixels.\n      // This is consistent with phantom's paperSize behavior.\n      unit = 'px';\n      valueText = text;\n    }\n    const value = Number(valueText);\n    assert(!isNaN(value), 'Failed to parse parameter value: ' + text);\n    pixels = value * unitToPixels[unit];\n  } else {\n    throw new Error('page.pdf() Cannot handle parameter type: ' + (typeof parameter));\n  }\n  return pixels / 96;\n}\n\nPage.Events = {\n  Close: 'close',\n  Console: 'console',\n  Dialog: 'dialog',\n  DOMContentLoaded: 'domcontentloaded',\n  Error: 'error',\n  // Can't use just 'error' due to node.js special treatment of error events.\n  // @see https://nodejs.org/api/events.html#events_error_events\n  PageError: 'pageerror',\n  Request: 'request',\n  Response: 'response',\n  RequestFailed: 'requestfailed',\n  RequestFinished: 'requestfinished',\n  FrameAttached: 'frameattached',\n  FrameDetached: 'framedetached',\n  FrameNavigated: 'framenavigated',\n  Load: 'load',\n  Metrics: 'metrics',\n  WorkerCreated: 'workercreated',\n  WorkerDestroyed: 'workerdestroyed',\n};\n\n\n/**\n * @typedef {Object} Network.Cookie\n * @property {string} name\n * @property {string} value\n * @property {string} domain\n * @property {string} path\n * @property {number} expires\n * @property {number} size\n * @property {boolean} httpOnly\n * @property {boolean} secure\n * @property {boolean} session\n * @property {(\"Strict\"|\"Lax\")=} sameSite\n */\n\n\n/**\n * @typedef {Object} Network.CookieParam\n * @property {string} name\n * @property {string} value\n * @property {string=} url\n * @property {string=} domain\n * @property {string=} path\n * @property {number=} expires\n * @property {boolean=} httpOnly\n * @property {boolean=} secure\n * @property {(\"Strict\"|\"Lax\")=} sameSite\n */\n\nclass ConsoleMessage {\n  /**\n   * @param {string} type\n   * @param {string} text\n   * @param {!Array<!Puppeteer.JSHandle>} args\n   */\n  constructor(type, text, args = []) {\n    this._type = type;\n    this._text = text;\n    this._args = args;\n  }\n\n  /**\n   * @return {string}\n   */\n  type() {\n    return this._type;\n  }\n\n  /**\n   * @return {string}\n   */\n  text() {\n    return this._text;\n  }\n\n  /**\n   * @return {!Array<!Puppeteer.JSHandle>}\n   */\n  args() {\n    return this._args;\n  }\n}\n\n\nmodule.exports = {Page};\nhelper.tracePublicAPI(Page);\n","/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {helper} = require('./helper');\nconst EventEmitter = require('events');\n\nclass Pipe extends EventEmitter {\n  /**\n   * @param {!NodeJS.WritableStream} pipeWrite\n   * @param {!NodeJS.ReadableStream} pipeRead\n   */\n  constructor(pipeWrite, pipeRead) {\n    super();\n    this._pipeWrite = pipeWrite;\n    this._pendingMessage = '';\n    this._eventListeners = [\n      helper.addEventListener(pipeRead, 'data', buffer => this._dispatch(buffer))\n    ];\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    this._pipeWrite.write(message);\n    this._pipeWrite.write('\\0');\n  }\n\n  /**\n   * @param {!Buffer} buffer\n   */\n  _dispatch(buffer) {\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this._pendingMessage += buffer.toString();\n      return;\n    }\n    const message = this._pendingMessage + buffer.toString(undefined, 0, end);\n    this.emit('message', message);\n\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      this.emit('message', buffer.toString(undefined, start, end));\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this._pendingMessage = buffer.toString(undefined, start);\n  }\n\n  close() {\n    this._pipeWrite = null;\n    helper.removeEventListeners(this._eventListeners);\n  }\n}\n\nmodule.exports = Pipe;\n","const {Page} = require('./Page');\nconst {helper} = require('./helper');\n\nclass Target {\n  /**\n   * @param {!Protocol.Target.TargetInfo} targetInfo\n   * @param {!Puppeteer.BrowserContext} browserContext\n   * @param {!function():!Promise<!Puppeteer.CDPSession>} sessionFactory\n   * @param {boolean} ignoreHTTPSErrors\n   * @param {?Puppeteer.Viewport} defaultViewport\n   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue\n   */\n  constructor(targetInfo, browserContext, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {\n    this._targetInfo = targetInfo;\n    this._browserContext = browserContext;\n    this._targetId = targetInfo.targetId;\n    this._sessionFactory = sessionFactory;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._defaultViewport = defaultViewport;\n    this._screenshotTaskQueue = screenshotTaskQueue;\n    /** @type {?Promise<!Puppeteer.Page>} */\n    this._pagePromise = null;\n    this._initializedPromise = new Promise(fulfill => this._initializedCallback = fulfill);\n    this._isClosedPromise = new Promise(fulfill => this._closedCallback = fulfill);\n    this._isInitialized = this._targetInfo.type !== 'page' || this._targetInfo.url !== '';\n    if (this._isInitialized)\n      this._initializedCallback(true);\n  }\n\n  /**\n   * @return {!Promise<!Puppeteer.CDPSession>}\n   */\n  createCDPSession() {\n    return this._sessionFactory();\n  }\n\n  /**\n   * @return {!Promise<?Page>}\n   */\n  async page() {\n    if ((this._targetInfo.type === 'page' || this._targetInfo.type === 'background_page') && !this._pagePromise) {\n      this._pagePromise = this._sessionFactory()\n          .then(client => Page.create(client, this, this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue));\n    }\n    return this._pagePromise;\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._targetInfo.url;\n  }\n\n  /**\n   * @return {\"page\"|\"background_page\"|\"service_worker\"|\"other\"|\"browser\"}\n   */\n  type() {\n    const type = this._targetInfo.type;\n    if (type === 'page' || type === 'background_page' || type === 'service_worker' || type === 'browser')\n      return type;\n    return 'other';\n  }\n\n  /**\n   * @return {!Puppeteer.Browser}\n   */\n  browser() {\n    return this._browserContext.browser();\n  }\n\n  /**\n   * @return {!Puppeteer.BrowserContext}\n   */\n  browserContext() {\n    return this._browserContext;\n  }\n\n  /**\n   * @return {Puppeteer.Target}\n   */\n  opener() {\n    const { openerId } = this._targetInfo;\n    if (!openerId)\n      return null;\n    return this.browser()._targets.get(openerId);\n  }\n\n  /**\n   * @param {!Protocol.Target.TargetInfo} targetInfo\n   */\n  _targetInfoChanged(targetInfo) {\n    this._targetInfo = targetInfo;\n\n    if (!this._isInitialized && (this._targetInfo.type !== 'page' || this._targetInfo.url !== '')) {\n      this._isInitialized = true;\n      this._initializedCallback(true);\n      return;\n    }\n  }\n}\n\nhelper.tracePublicAPI(Target);\n\nmodule.exports = {Target};\n","class TaskQueue {\n  constructor() {\n    this._chain = Promise.resolve();\n  }\n\n  /**\n   * @param {function()} task\n   * @return {!Promise}\n   */\n  postTask(task) {\n    const result = this._chain.then(task);\n    this._chain = result.catch(() => {});\n    return result;\n  }\n}\n\nmodule.exports = {TaskQueue};","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {helper, assert} = require('./helper');\nconst fs = require('fs');\n\nconst openAsync = helper.promisify(fs.open);\nconst writeAsync = helper.promisify(fs.write);\nconst closeAsync = helper.promisify(fs.close);\n\nclass Tracing {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._recording = false;\n    this._path = '';\n  }\n\n  /**\n   * @param {!Object} options\n   */\n  async start(options) {\n    assert(!this._recording, 'Cannot start recording trace while already recording trace.');\n\n    const defaultCategories = [\n      '-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline',\n      'disabled-by-default-devtools.timeline.frame', 'toplevel',\n      'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack',\n      'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'\n    ];\n    const categoriesArray = options.categories || defaultCategories;\n\n    if (options.screenshots)\n      categoriesArray.push('disabled-by-default-devtools.screenshot');\n\n    this._path = options.path;\n    this._recording = true;\n    await this._client.send('Tracing.start', {\n      transferMode: 'ReturnAsStream',\n      categories: categoriesArray.join(',')\n    });\n  }\n\n  async stop() {\n    let fulfill;\n    const contentPromise = new Promise(x => fulfill = x);\n    this._client.once('Tracing.tracingComplete', event => {\n      this._readStream(event.stream, this._path).then(fulfill);\n    });\n    await this._client.send('Tracing.end');\n    this._recording = false;\n    return contentPromise;\n  }\n\n  /**\n   * @param {string} handle\n   * @param {string} path\n   */\n  async _readStream(handle, path) {\n    let eof = false;\n    let file;\n    if (path)\n      file = await openAsync(path, 'w');\n    const bufs = [];\n    while (!eof) {\n      const response = await this._client.send('IO.read', {handle});\n      eof = response.eof;\n      bufs.push(Buffer.from(response.data));\n      if (path)\n        await writeAsync(file, response.data);\n    }\n    if (path)\n      await closeAsync(file);\n    await this._client.send('IO.close', {handle});\n    let resultBuffer = null;\n    try {\n      resultBuffer = Buffer.concat(bufs);\n    } finally {\n      return resultBuffer;\n    }\n  }\n}\nhelper.tracePublicAPI(Tracing);\n\nmodule.exports = Tracing;\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {Object} KeyDefinition\n * @property {number=} keyCode\n * @property {number=} shiftKeyCode\n * @property {string=} key\n * @property {string=} shiftKey\n * @property {string=} code\n * @property {string=} text\n * @property {string=} shiftText\n * @property {number=} location\n */\n\n/**\n * @type {Object<string, KeyDefinition>}\n */\nmodule.exports = {\n  '0': {'keyCode': 48, 'key': '0', 'code': 'Digit0'},\n  '1': {'keyCode': 49, 'key': '1', 'code': 'Digit1'},\n  '2': {'keyCode': 50, 'key': '2', 'code': 'Digit2'},\n  '3': {'keyCode': 51, 'key': '3', 'code': 'Digit3'},\n  '4': {'keyCode': 52, 'key': '4', 'code': 'Digit4'},\n  '5': {'keyCode': 53, 'key': '5', 'code': 'Digit5'},\n  '6': {'keyCode': 54, 'key': '6', 'code': 'Digit6'},\n  '7': {'keyCode': 55, 'key': '7', 'code': 'Digit7'},\n  '8': {'keyCode': 56, 'key': '8', 'code': 'Digit8'},\n  '9': {'keyCode': 57, 'key': '9', 'code': 'Digit9'},\n  'Power': {'key': 'Power', 'code': 'Power'},\n  'Eject': {'key': 'Eject', 'code': 'Eject'},\n  'Abort': {'keyCode': 3, 'code': 'Abort', 'key': 'Cancel'},\n  'Help': {'keyCode': 6, 'code': 'Help', 'key': 'Help'},\n  'Backspace': {'keyCode': 8, 'code': 'Backspace', 'key': 'Backspace'},\n  'Tab': {'keyCode': 9, 'code': 'Tab', 'key': 'Tab'},\n  'Numpad5': {'keyCode': 12, 'shiftKeyCode': 101, 'key': 'Clear', 'code': 'Numpad5', 'shiftKey': '5', 'location': 3},\n  'NumpadEnter': {'keyCode': 13, 'code': 'NumpadEnter', 'key': 'Enter', 'text': '\\r', 'location': 3},\n  'Enter': {'keyCode': 13, 'code': 'Enter', 'key': 'Enter', 'text': '\\r'},\n  '\\r': {'keyCode': 13, 'code': 'Enter', 'key': 'Enter', 'text': '\\r'},\n  '\\n': {'keyCode': 13, 'code': 'Enter', 'key': 'Enter', 'text': '\\r'},\n  'ShiftLeft': {'keyCode': 16, 'code': 'ShiftLeft', 'key': 'Shift', 'location': 1},\n  'ShiftRight': {'keyCode': 16, 'code': 'ShiftRight', 'key': 'Shift', 'location': 2},\n  'ControlLeft': {'keyCode': 17, 'code': 'ControlLeft', 'key': 'Control', 'location': 1},\n  'ControlRight': {'keyCode': 17, 'code': 'ControlRight', 'key': 'Control', 'location': 2},\n  'AltLeft': {'keyCode': 18, 'code': 'AltLeft', 'key': 'Alt', 'location': 1},\n  'AltRight': {'keyCode': 18, 'code': 'AltRight', 'key': 'Alt', 'location': 2},\n  'Pause': {'keyCode': 19, 'code': 'Pause', 'key': 'Pause'},\n  'CapsLock': {'keyCode': 20, 'code': 'CapsLock', 'key': 'CapsLock'},\n  'Escape': {'keyCode': 27, 'code': 'Escape', 'key': 'Escape'},\n  'Convert': {'keyCode': 28, 'code': 'Convert', 'key': 'Convert'},\n  'NonConvert': {'keyCode': 29, 'code': 'NonConvert', 'key': 'NonConvert'},\n  'Space': {'keyCode': 32, 'code': 'Space', 'key': ' '},\n  'Numpad9': {'keyCode': 33, 'shiftKeyCode': 105, 'key': 'PageUp', 'code': 'Numpad9', 'shiftKey': '9', 'location': 3},\n  'PageUp': {'keyCode': 33, 'code': 'PageUp', 'key': 'PageUp'},\n  'Numpad3': {'keyCode': 34, 'shiftKeyCode': 99, 'key': 'PageDown', 'code': 'Numpad3', 'shiftKey': '3', 'location': 3},\n  'PageDown': {'keyCode': 34, 'code': 'PageDown', 'key': 'PageDown'},\n  'End': {'keyCode': 35, 'code': 'End', 'key': 'End'},\n  'Numpad1': {'keyCode': 35, 'shiftKeyCode': 97, 'key': 'End', 'code': 'Numpad1', 'shiftKey': '1', 'location': 3},\n  'Home': {'keyCode': 36, 'code': 'Home', 'key': 'Home'},\n  'Numpad7': {'keyCode': 36, 'shiftKeyCode': 103, 'key': 'Home', 'code': 'Numpad7', 'shiftKey': '7', 'location': 3},\n  'ArrowLeft': {'keyCode': 37, 'code': 'ArrowLeft', 'key': 'ArrowLeft'},\n  'Numpad4': {'keyCode': 37, 'shiftKeyCode': 100, 'key': 'ArrowLeft', 'code': 'Numpad4', 'shiftKey': '4', 'location': 3},\n  'Numpad8': {'keyCode': 38, 'shiftKeyCode': 104, 'key': 'ArrowUp', 'code': 'Numpad8', 'shiftKey': '8', 'location': 3},\n  'ArrowUp': {'keyCode': 38, 'code': 'ArrowUp', 'key': 'ArrowUp'},\n  'ArrowRight': {'keyCode': 39, 'code': 'ArrowRight', 'key': 'ArrowRight'},\n  'Numpad6': {'keyCode': 39, 'shiftKeyCode': 102, 'key': 'ArrowRight', 'code': 'Numpad6', 'shiftKey': '6', 'location': 3},\n  'Numpad2': {'keyCode': 40, 'shiftKeyCode': 98, 'key': 'ArrowDown', 'code': 'Numpad2', 'shiftKey': '2', 'location': 3},\n  'ArrowDown': {'keyCode': 40, 'code': 'ArrowDown', 'key': 'ArrowDown'},\n  'Select': {'keyCode': 41, 'code': 'Select', 'key': 'Select'},\n  'Open': {'keyCode': 43, 'code': 'Open', 'key': 'Execute'},\n  'PrintScreen': {'keyCode': 44, 'code': 'PrintScreen', 'key': 'PrintScreen'},\n  'Insert': {'keyCode': 45, 'code': 'Insert', 'key': 'Insert'},\n  'Numpad0': {'keyCode': 45, 'shiftKeyCode': 96, 'key': 'Insert', 'code': 'Numpad0', 'shiftKey': '0', 'location': 3},\n  'Delete': {'keyCode': 46, 'code': 'Delete', 'key': 'Delete'},\n  'NumpadDecimal': {'keyCode': 46, 'shiftKeyCode': 110, 'code': 'NumpadDecimal', 'key': '\\u0000', 'shiftKey': '.', 'location': 3},\n  'Digit0': {'keyCode': 48, 'code': 'Digit0', 'shiftKey': ')', 'key': '0'},\n  'Digit1': {'keyCode': 49, 'code': 'Digit1', 'shiftKey': '!', 'key': '1'},\n  'Digit2': {'keyCode': 50, 'code': 'Digit2', 'shiftKey': '@', 'key': '2'},\n  'Digit3': {'keyCode': 51, 'code': 'Digit3', 'shiftKey': '#', 'key': '3'},\n  'Digit4': {'keyCode': 52, 'code': 'Digit4', 'shiftKey': '$', 'key': '4'},\n  'Digit5': {'keyCode': 53, 'code': 'Digit5', 'shiftKey': '%', 'key': '5'},\n  'Digit6': {'keyCode': 54, 'code': 'Digit6', 'shiftKey': '^', 'key': '6'},\n  'Digit7': {'keyCode': 55, 'code': 'Digit7', 'shiftKey': '&', 'key': '7'},\n  'Digit8': {'keyCode': 56, 'code': 'Digit8', 'shiftKey': '*', 'key': '8'},\n  'Digit9': {'keyCode': 57, 'code': 'Digit9', 'shiftKey': '\\(', 'key': '9'},\n  'KeyA': {'keyCode': 65, 'code': 'KeyA', 'shiftKey': 'A', 'key': 'a'},\n  'KeyB': {'keyCode': 66, 'code': 'KeyB', 'shiftKey': 'B', 'key': 'b'},\n  'KeyC': {'keyCode': 67, 'code': 'KeyC', 'shiftKey': 'C', 'key': 'c'},\n  'KeyD': {'keyCode': 68, 'code': 'KeyD', 'shiftKey': 'D', 'key': 'd'},\n  'KeyE': {'keyCode': 69, 'code': 'KeyE', 'shiftKey': 'E', 'key': 'e'},\n  'KeyF': {'keyCode': 70, 'code': 'KeyF', 'shiftKey': 'F', 'key': 'f'},\n  'KeyG': {'keyCode': 71, 'code': 'KeyG', 'shiftKey': 'G', 'key': 'g'},\n  'KeyH': {'keyCode': 72, 'code': 'KeyH', 'shiftKey': 'H', 'key': 'h'},\n  'KeyI': {'keyCode': 73, 'code': 'KeyI', 'shiftKey': 'I', 'key': 'i'},\n  'KeyJ': {'keyCode': 74, 'code': 'KeyJ', 'shiftKey': 'J', 'key': 'j'},\n  'KeyK': {'keyCode': 75, 'code': 'KeyK', 'shiftKey': 'K', 'key': 'k'},\n  'KeyL': {'keyCode': 76, 'code': 'KeyL', 'shiftKey': 'L', 'key': 'l'},\n  'KeyM': {'keyCode': 77, 'code': 'KeyM', 'shiftKey': 'M', 'key': 'm'},\n  'KeyN': {'keyCode': 78, 'code': 'KeyN', 'shiftKey': 'N', 'key': 'n'},\n  'KeyO': {'keyCode': 79, 'code': 'KeyO', 'shiftKey': 'O', 'key': 'o'},\n  'KeyP': {'keyCode': 80, 'code': 'KeyP', 'shiftKey': 'P', 'key': 'p'},\n  'KeyQ': {'keyCode': 81, 'code': 'KeyQ', 'shiftKey': 'Q', 'key': 'q'},\n  'KeyR': {'keyCode': 82, 'code': 'KeyR', 'shiftKey': 'R', 'key': 'r'},\n  'KeyS': {'keyCode': 83, 'code': 'KeyS', 'shiftKey': 'S', 'key': 's'},\n  'KeyT': {'keyCode': 84, 'code': 'KeyT', 'shiftKey': 'T', 'key': 't'},\n  'KeyU': {'keyCode': 85, 'code': 'KeyU', 'shiftKey': 'U', 'key': 'u'},\n  'KeyV': {'keyCode': 86, 'code': 'KeyV', 'shiftKey': 'V', 'key': 'v'},\n  'KeyW': {'keyCode': 87, 'code': 'KeyW', 'shiftKey': 'W', 'key': 'w'},\n  'KeyX': {'keyCode': 88, 'code': 'KeyX', 'shiftKey': 'X', 'key': 'x'},\n  'KeyY': {'keyCode': 89, 'code': 'KeyY', 'shiftKey': 'Y', 'key': 'y'},\n  'KeyZ': {'keyCode': 90, 'code': 'KeyZ', 'shiftKey': 'Z', 'key': 'z'},\n  'MetaLeft': {'keyCode': 91, 'code': 'MetaLeft', 'key': 'Meta'},\n  'MetaRight': {'keyCode': 92, 'code': 'MetaRight', 'key': 'Meta'},\n  'ContextMenu': {'keyCode': 93, 'code': 'ContextMenu', 'key': 'ContextMenu'},\n  'NumpadMultiply': {'keyCode': 106, 'code': 'NumpadMultiply', 'key': '*', 'location': 3},\n  'NumpadAdd': {'keyCode': 107, 'code': 'NumpadAdd', 'key': '+', 'location': 3},\n  'NumpadSubtract': {'keyCode': 109, 'code': 'NumpadSubtract', 'key': '-', 'location': 3},\n  'NumpadDivide': {'keyCode': 111, 'code': 'NumpadDivide', 'key': '/', 'location': 3},\n  'F1': {'keyCode': 112, 'code': 'F1', 'key': 'F1'},\n  'F2': {'keyCode': 113, 'code': 'F2', 'key': 'F2'},\n  'F3': {'keyCode': 114, 'code': 'F3', 'key': 'F3'},\n  'F4': {'keyCode': 115, 'code': 'F4', 'key': 'F4'},\n  'F5': {'keyCode': 116, 'code': 'F5', 'key': 'F5'},\n  'F6': {'keyCode': 117, 'code': 'F6', 'key': 'F6'},\n  'F7': {'keyCode': 118, 'code': 'F7', 'key': 'F7'},\n  'F8': {'keyCode': 119, 'code': 'F8', 'key': 'F8'},\n  'F9': {'keyCode': 120, 'code': 'F9', 'key': 'F9'},\n  'F10': {'keyCode': 121, 'code': 'F10', 'key': 'F10'},\n  'F11': {'keyCode': 122, 'code': 'F11', 'key': 'F11'},\n  'F12': {'keyCode': 123, 'code': 'F12', 'key': 'F12'},\n  'F13': {'keyCode': 124, 'code': 'F13', 'key': 'F13'},\n  'F14': {'keyCode': 125, 'code': 'F14', 'key': 'F14'},\n  'F15': {'keyCode': 126, 'code': 'F15', 'key': 'F15'},\n  'F16': {'keyCode': 127, 'code': 'F16', 'key': 'F16'},\n  'F17': {'keyCode': 128, 'code': 'F17', 'key': 'F17'},\n  'F18': {'keyCode': 129, 'code': 'F18', 'key': 'F18'},\n  'F19': {'keyCode': 130, 'code': 'F19', 'key': 'F19'},\n  'F20': {'keyCode': 131, 'code': 'F20', 'key': 'F20'},\n  'F21': {'keyCode': 132, 'code': 'F21', 'key': 'F21'},\n  'F22': {'keyCode': 133, 'code': 'F22', 'key': 'F22'},\n  'F23': {'keyCode': 134, 'code': 'F23', 'key': 'F23'},\n  'F24': {'keyCode': 135, 'code': 'F24', 'key': 'F24'},\n  'NumLock': {'keyCode': 144, 'code': 'NumLock', 'key': 'NumLock'},\n  'ScrollLock': {'keyCode': 145, 'code': 'ScrollLock', 'key': 'ScrollLock'},\n  'AudioVolumeMute': {'keyCode': 173, 'code': 'AudioVolumeMute', 'key': 'AudioVolumeMute'},\n  'AudioVolumeDown': {'keyCode': 174, 'code': 'AudioVolumeDown', 'key': 'AudioVolumeDown'},\n  'AudioVolumeUp': {'keyCode': 175, 'code': 'AudioVolumeUp', 'key': 'AudioVolumeUp'},\n  'MediaTrackNext': {'keyCode': 176, 'code': 'MediaTrackNext', 'key': 'MediaTrackNext'},\n  'MediaTrackPrevious': {'keyCode': 177, 'code': 'MediaTrackPrevious', 'key': 'MediaTrackPrevious'},\n  'MediaStop': {'keyCode': 178, 'code': 'MediaStop', 'key': 'MediaStop'},\n  'MediaPlayPause': {'keyCode': 179, 'code': 'MediaPlayPause', 'key': 'MediaPlayPause'},\n  'Semicolon': {'keyCode': 186, 'code': 'Semicolon', 'shiftKey': ':', 'key': ';'},\n  'Equal': {'keyCode': 187, 'code': 'Equal', 'shiftKey': '+', 'key': '='},\n  'NumpadEqual': {'keyCode': 187, 'code': 'NumpadEqual', 'key': '=', 'location': 3},\n  'Comma': {'keyCode': 188, 'code': 'Comma', 'shiftKey': '\\<', 'key': ','},\n  'Minus': {'keyCode': 189, 'code': 'Minus', 'shiftKey': '_', 'key': '-'},\n  'Period': {'keyCode': 190, 'code': 'Period', 'shiftKey': '>', 'key': '.'},\n  'Slash': {'keyCode': 191, 'code': 'Slash', 'shiftKey': '?', 'key': '/'},\n  'Backquote': {'keyCode': 192, 'code': 'Backquote', 'shiftKey': '~', 'key': '`'},\n  'BracketLeft': {'keyCode': 219, 'code': 'BracketLeft', 'shiftKey': '{', 'key': '['},\n  'Backslash': {'keyCode': 220, 'code': 'Backslash', 'shiftKey': '|', 'key': '\\\\'},\n  'BracketRight': {'keyCode': 221, 'code': 'BracketRight', 'shiftKey': '}', 'key': ']'},\n  'Quote': {'keyCode': 222, 'code': 'Quote', 'shiftKey': '\"', 'key': '\\''},\n  'AltGraph': {'keyCode': 225, 'code': 'AltGraph', 'key': 'AltGraph'},\n  'Props': {'keyCode': 247, 'code': 'Props', 'key': 'CrSel'},\n  'Cancel': {'keyCode': 3, 'key': 'Cancel', 'code': 'Abort'},\n  'Clear': {'keyCode': 12, 'key': 'Clear', 'code': 'Numpad5', 'location': 3},\n  'Shift': {'keyCode': 16, 'key': 'Shift', 'code': 'ShiftLeft'},\n  'Control': {'keyCode': 17, 'key': 'Control', 'code': 'ControlLeft'},\n  'Alt': {'keyCode': 18, 'key': 'Alt', 'code': 'AltLeft'},\n  'Accept': {'keyCode': 30, 'key': 'Accept'},\n  'ModeChange': {'keyCode': 31, 'key': 'ModeChange'},\n  ' ': {'keyCode': 32, 'key': ' ', 'code': 'Space'},\n  'Print': {'keyCode': 42, 'key': 'Print'},\n  'Execute': {'keyCode': 43, 'key': 'Execute', 'code': 'Open'},\n  '\\u0000': {'keyCode': 46, 'key': '\\u0000', 'code': 'NumpadDecimal', 'location': 3},\n  'a': {'keyCode': 65, 'key': 'a', 'code': 'KeyA'},\n  'b': {'keyCode': 66, 'key': 'b', 'code': 'KeyB'},\n  'c': {'keyCode': 67, 'key': 'c', 'code': 'KeyC'},\n  'd': {'keyCode': 68, 'key': 'd', 'code': 'KeyD'},\n  'e': {'keyCode': 69, 'key': 'e', 'code': 'KeyE'},\n  'f': {'keyCode': 70, 'key': 'f', 'code': 'KeyF'},\n  'g': {'keyCode': 71, 'key': 'g', 'code': 'KeyG'},\n  'h': {'keyCode': 72, 'key': 'h', 'code': 'KeyH'},\n  'i': {'keyCode': 73, 'key': 'i', 'code': 'KeyI'},\n  'j': {'keyCode': 74, 'key': 'j', 'code': 'KeyJ'},\n  'k': {'keyCode': 75, 'key': 'k', 'code': 'KeyK'},\n  'l': {'keyCode': 76, 'key': 'l', 'code': 'KeyL'},\n  'm': {'keyCode': 77, 'key': 'm', 'code': 'KeyM'},\n  'n': {'keyCode': 78, 'key': 'n', 'code': 'KeyN'},\n  'o': {'keyCode': 79, 'key': 'o', 'code': 'KeyO'},\n  'p': {'keyCode': 80, 'key': 'p', 'code': 'KeyP'},\n  'q': {'keyCode': 81, 'key': 'q', 'code': 'KeyQ'},\n  'r': {'keyCode': 82, 'key': 'r', 'code': 'KeyR'},\n  's': {'keyCode': 83, 'key': 's', 'code': 'KeyS'},\n  't': {'keyCode': 84, 'key': 't', 'code': 'KeyT'},\n  'u': {'keyCode': 85, 'key': 'u', 'code': 'KeyU'},\n  'v': {'keyCode': 86, 'key': 'v', 'code': 'KeyV'},\n  'w': {'keyCode': 87, 'key': 'w', 'code': 'KeyW'},\n  'x': {'keyCode': 88, 'key': 'x', 'code': 'KeyX'},\n  'y': {'keyCode': 89, 'key': 'y', 'code': 'KeyY'},\n  'z': {'keyCode': 90, 'key': 'z', 'code': 'KeyZ'},\n  'Meta': {'keyCode': 91, 'key': 'Meta', 'code': 'MetaLeft'},\n  '*': {'keyCode': 106, 'key': '*', 'code': 'NumpadMultiply', 'location': 3},\n  '+': {'keyCode': 107, 'key': '+', 'code': 'NumpadAdd', 'location': 3},\n  '-': {'keyCode': 109, 'key': '-', 'code': 'NumpadSubtract', 'location': 3},\n  '/': {'keyCode': 111, 'key': '/', 'code': 'NumpadDivide', 'location': 3},\n  ';': {'keyCode': 186, 'key': ';', 'code': 'Semicolon'},\n  '=': {'keyCode': 187, 'key': '=', 'code': 'Equal'},\n  ',': {'keyCode': 188, 'key': ',', 'code': 'Comma'},\n  '.': {'keyCode': 190, 'key': '.', 'code': 'Period'},\n  '`': {'keyCode': 192, 'key': '`', 'code': 'Backquote'},\n  '[': {'keyCode': 219, 'key': '[', 'code': 'BracketLeft'},\n  '\\\\': {'keyCode': 220, 'key': '\\\\', 'code': 'Backslash'},\n  ']': {'keyCode': 221, 'key': ']', 'code': 'BracketRight'},\n  '\\'': {'keyCode': 222, 'key': '\\'', 'code': 'Quote'},\n  'Attn': {'keyCode': 246, 'key': 'Attn'},\n  'CrSel': {'keyCode': 247, 'key': 'CrSel', 'code': 'Props'},\n  'ExSel': {'keyCode': 248, 'key': 'ExSel'},\n  'EraseEof': {'keyCode': 249, 'key': 'EraseEof'},\n  'Play': {'keyCode': 250, 'key': 'Play'},\n  'ZoomOut': {'keyCode': 251, 'key': 'ZoomOut'},\n  ')': {'keyCode': 48, 'key': ')', 'code': 'Digit0'},\n  '!': {'keyCode': 49, 'key': '!', 'code': 'Digit1'},\n  '@': {'keyCode': 50, 'key': '@', 'code': 'Digit2'},\n  '#': {'keyCode': 51, 'key': '#', 'code': 'Digit3'},\n  '$': {'keyCode': 52, 'key': '$', 'code': 'Digit4'},\n  '%': {'keyCode': 53, 'key': '%', 'code': 'Digit5'},\n  '^': {'keyCode': 54, 'key': '^', 'code': 'Digit6'},\n  '&': {'keyCode': 55, 'key': '&', 'code': 'Digit7'},\n  '(': {'keyCode': 57, 'key': '\\(', 'code': 'Digit9'},\n  'A': {'keyCode': 65, 'key': 'A', 'code': 'KeyA'},\n  'B': {'keyCode': 66, 'key': 'B', 'code': 'KeyB'},\n  'C': {'keyCode': 67, 'key': 'C', 'code': 'KeyC'},\n  'D': {'keyCode': 68, 'key': 'D', 'code': 'KeyD'},\n  'E': {'keyCode': 69, 'key': 'E', 'code': 'KeyE'},\n  'F': {'keyCode': 70, 'key': 'F', 'code': 'KeyF'},\n  'G': {'keyCode': 71, 'key': 'G', 'code': 'KeyG'},\n  'H': {'keyCode': 72, 'key': 'H', 'code': 'KeyH'},\n  'I': {'keyCode': 73, 'key': 'I', 'code': 'KeyI'},\n  'J': {'keyCode': 74, 'key': 'J', 'code': 'KeyJ'},\n  'K': {'keyCode': 75, 'key': 'K', 'code': 'KeyK'},\n  'L': {'keyCode': 76, 'key': 'L', 'code': 'KeyL'},\n  'M': {'keyCode': 77, 'key': 'M', 'code': 'KeyM'},\n  'N': {'keyCode': 78, 'key': 'N', 'code': 'KeyN'},\n  'O': {'keyCode': 79, 'key': 'O', 'code': 'KeyO'},\n  'P': {'keyCode': 80, 'key': 'P', 'code': 'KeyP'},\n  'Q': {'keyCode': 81, 'key': 'Q', 'code': 'KeyQ'},\n  'R': {'keyCode': 82, 'key': 'R', 'code': 'KeyR'},\n  'S': {'keyCode': 83, 'key': 'S', 'code': 'KeyS'},\n  'T': {'keyCode': 84, 'key': 'T', 'code': 'KeyT'},\n  'U': {'keyCode': 85, 'key': 'U', 'code': 'KeyU'},\n  'V': {'keyCode': 86, 'key': 'V', 'code': 'KeyV'},\n  'W': {'keyCode': 87, 'key': 'W', 'code': 'KeyW'},\n  'X': {'keyCode': 88, 'key': 'X', 'code': 'KeyX'},\n  'Y': {'keyCode': 89, 'key': 'Y', 'code': 'KeyY'},\n  'Z': {'keyCode': 90, 'key': 'Z', 'code': 'KeyZ'},\n  ':': {'keyCode': 186, 'key': ':', 'code': 'Semicolon'},\n  '<': {'keyCode': 188, 'key': '\\<', 'code': 'Comma'},\n  '_': {'keyCode': 189, 'key': '_', 'code': 'Minus'},\n  '>': {'keyCode': 190, 'key': '>', 'code': 'Period'},\n  '?': {'keyCode': 191, 'key': '?', 'code': 'Slash'},\n  '~': {'keyCode': 192, 'key': '~', 'code': 'Backquote'},\n  '{': {'keyCode': 219, 'key': '{', 'code': 'BracketLeft'},\n  '|': {'keyCode': 220, 'key': '|', 'code': 'Backslash'},\n  '}': {'keyCode': 221, 'key': '}', 'code': 'BracketRight'},\n  '\"': {'keyCode': 222, 'key': '\"', 'code': 'Quote'}\n};","/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter = require('events');\nconst {helper, debugError} = require('./helper');\nconst {ExecutionContext, JSHandle} = require('./ExecutionContext');\n\nclass Worker extends EventEmitter {\n  /**\n   * @param {Puppeteer.CDPSession} client\n   * @param {string} url\n   * @param {function(!string, !Array<!JSHandle>)} consoleAPICalled\n   * @param {function(!Protocol.Runtime.ExceptionDetails)} exceptionThrown\n   */\n  constructor(client, url, consoleAPICalled, exceptionThrown) {\n    super();\n    this._client = client;\n    this._url = url;\n    this._executionContextPromise = new Promise(x => this._executionContextCallback = x);\n    /** @type {function(!Protocol.Runtime.RemoteObject):!JSHandle} */\n    let jsHandleFactory;\n    this._client.once('Runtime.executionContextCreated', async event => {\n      jsHandleFactory = remoteObject => new JSHandle(executionContext, client, remoteObject);\n      const executionContext = new ExecutionContext(client, event.context, jsHandleFactory, null);\n      this._executionContextCallback(executionContext);\n    });\n    // This might fail if the target is closed before we recieve all execution contexts.\n    this._client.send('Runtime.enable', {}).catch(debugError);\n\n    this._client.on('Runtime.consoleAPICalled', event => consoleAPICalled(event.type, event.args.map(jsHandleFactory)));\n    this._client.on('Runtime.exceptionThrown', exception => exceptionThrown(exception.exceptionDetails));\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {!Promise<ExecutionContext>}\n   */\n  async executionContext() {\n    return this._executionContextPromise;\n  }\n\n  /**\n   * @param {function()|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<*>}\n   */\n  async evaluate(pageFunction, ...args) {\n    return (await this._executionContextPromise).evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @param {function()|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<!JSHandle>}\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);\n  }\n}\n\nmodule.exports = {Worker};\nhelper.tracePublicAPI(Worker);\n","/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst fs = require('fs');\nconst path = require('path');\nconst {TimeoutError} = require('./Errors');\n\nconst debugError = require('debug')(`puppeteer:error`);\n/** @type {?Map<string, boolean>} */\nlet apiCoverage = null;\nlet projectRoot = null;\nclass Helper {\n  /**\n   * @param {Function|string} fun\n   * @param {!Array<*>} args\n   * @return {string}\n   */\n  static evaluationString(fun, ...args) {\n    if (Helper.isString(fun)) {\n      assert(args.length === 0, 'Cannot evaluate a string with arguments');\n      return /** @type {string} */ (fun);\n    }\n    return `(${fun})(${args.map(serializeArgument).join(',')})`;\n\n    /**\n     * @param {*} arg\n     * @return {string}\n     */\n    function serializeArgument(arg) {\n      if (Object.is(arg, undefined))\n        return 'undefined';\n      return JSON.stringify(arg);\n    }\n  }\n\n  /**\n   * @return {string}\n   */\n  static projectRoot() {\n    if (!projectRoot) {\n      // Project root will be different for node6-transpiled code.\n      projectRoot = fs.existsSync(path.join(__dirname, '..', 'package.json')) ? path.join(__dirname, '..') : path.join(__dirname, '..', '..');\n    }\n    return projectRoot;\n  }\n\n  /**\n   * @param {!Protocol.Runtime.ExceptionDetails} exceptionDetails\n   * @return {string}\n   */\n  static getExceptionMessage(exceptionDetails) {\n    if (exceptionDetails.exception)\n      return exceptionDetails.exception.description || exceptionDetails.exception.value;\n    let message = exceptionDetails.text;\n    if (exceptionDetails.stackTrace) {\n      for (const callframe of exceptionDetails.stackTrace.callFrames) {\n        const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;\n        const functionName = callframe.functionName || '<anonymous>';\n        message += `\\n    at ${functionName} (${location})`;\n      }\n    }\n    return message;\n  }\n\n  /**\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   * @return {*}\n   */\n  static valueFromRemoteObject(remoteObject) {\n    assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');\n    if (remoteObject.unserializableValue) {\n      switch (remoteObject.unserializableValue) {\n        case '-0':\n          return -0;\n        case 'NaN':\n          return NaN;\n        case 'Infinity':\n          return Infinity;\n        case '-Infinity':\n          return -Infinity;\n        default:\n          throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);\n      }\n    }\n    return remoteObject.value;\n  }\n\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   */\n  static async releaseObject(client, remoteObject) {\n    if (!remoteObject.objectId)\n      return;\n    await client.send('Runtime.releaseObject', {objectId: remoteObject.objectId}).catch(error => {\n      // Exceptions might happen in case of a page been navigated or closed.\n      // Swallow these since they are harmless and we don't leak anything in this case.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {!Object} classType\n   * @param {string=} publicName\n   */\n  static tracePublicAPI(classType, publicName) {\n    let className = publicName || classType.prototype.constructor.name;\n    className = className.substring(0, 1).toLowerCase() + className.substring(1);\n    const debug = require('debug')(`puppeteer:${className}`);\n    if (!debug.enabled && !apiCoverage)\n      return;\n    for (const methodName of Reflect.ownKeys(classType.prototype)) {\n      const method = Reflect.get(classType.prototype, methodName);\n      if (methodName === 'constructor' || typeof methodName !== 'string' || methodName.startsWith('_') || typeof method !== 'function')\n        continue;\n      if (apiCoverage)\n        apiCoverage.set(`${className}.${methodName}`, false);\n      Reflect.set(classType.prototype, methodName, function(...args) {\n        const argsText = args.map(stringifyArgument).join(', ');\n        const callsite = `${className}.${methodName}(${argsText})`;\n        if (debug.enabled)\n          debug(callsite);\n        if (apiCoverage)\n          apiCoverage.set(`${className}.${methodName}`, true);\n        return method.call(this, ...args);\n      });\n    }\n\n    if (classType.Events) {\n      if (apiCoverage) {\n        for (const event of Object.values(classType.Events))\n          apiCoverage.set(`${className}.emit(${JSON.stringify(event)})`, false);\n      }\n      const method = Reflect.get(classType.prototype, 'emit');\n      Reflect.set(classType.prototype, 'emit', function(event, ...args) {\n        const argsText = [JSON.stringify(event)].concat(args.map(stringifyArgument)).join(', ');\n        if (debug.enabled && this.listenerCount(event))\n          debug(`${className}.emit(${argsText})`);\n        if (apiCoverage && this.listenerCount(event))\n          apiCoverage.set(`${className}.emit(${JSON.stringify(event)})`, true);\n        return method.call(this, event, ...args);\n      });\n    }\n\n    /**\n     * @param {!Object} arg\n     * @return {string}\n     */\n    function stringifyArgument(arg) {\n      if (Helper.isString(arg) || Helper.isNumber(arg) || !arg)\n        return JSON.stringify(arg);\n      if (typeof arg === 'function') {\n        let text = arg.toString().split('\\n').map(line => line.trim()).join('');\n        if (text.length > 20)\n          text = text.substring(0, 20) + '…';\n        return `\"${text}\"`;\n      }\n      const state = {};\n      const keys = Object.keys(arg);\n      for (const key of keys) {\n        const value = arg[key];\n        if (Helper.isString(value) || Helper.isNumber(value))\n          state[key] = JSON.stringify(value);\n      }\n      const name = arg.constructor.name === 'Object' ? '' : arg.constructor.name;\n      return name + JSON.stringify(state);\n    }\n  }\n\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {string} eventName\n   * @param {function(?)} handler\n   * @return {{emitter: !NodeJS.EventEmitter, eventName: string, handler: function(?)}}\n   */\n  static addEventListener(emitter, eventName, handler) {\n    emitter.on(eventName, handler);\n    return { emitter, eventName, handler };\n  }\n\n  /**\n   * @param {!Array<{emitter: !NodeJS.EventEmitter, eventName: string, handler: function(?)}>} listeners\n   */\n  static removeEventListeners(listeners) {\n    for (const listener of listeners)\n      listener.emitter.removeListener(listener.eventName, listener.handler);\n    listeners.splice(0, listeners.length);\n  }\n\n  /**\n   * @return {?Map<string, boolean>}\n   */\n  static publicAPICoverage() {\n    return apiCoverage;\n  }\n\n  static recordPublicAPICoverage() {\n    apiCoverage = new Map();\n  }\n\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n  static isString(obj) {\n    return typeof obj === 'string' || obj instanceof String;\n  }\n\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n  static isNumber(obj) {\n    return typeof obj === 'number' || obj instanceof Number;\n  }\n\n  static promisify(nodeFunction) {\n    function promisified(...args) {\n      return new Promise((resolve, reject) => {\n        function callback(err, ...result) {\n          if (err)\n            return reject(err);\n          if (result.length === 1)\n            return resolve(result[0]);\n          return resolve(result);\n        }\n        nodeFunction.call(null, ...args, callback);\n      });\n    }\n    return promisified;\n  }\n\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {string} eventName\n   * @param {function} predicate\n   * @return {!Promise}\n   */\n  static waitForEvent(emitter, eventName, predicate, timeout) {\n    let eventTimeout, resolveCallback, rejectCallback;\n    const promise = new Promise((resolve, reject) => {\n      resolveCallback = resolve;\n      rejectCallback = reject;\n    });\n    const listener = Helper.addEventListener(emitter, eventName, event => {\n      if (!predicate(event))\n        return;\n      cleanup();\n      resolveCallback(event);\n    });\n    if (timeout) {\n      eventTimeout = setTimeout(() => {\n        cleanup();\n        rejectCallback(new TimeoutError('Timeout exceeded while waiting for event'));\n      }, timeout);\n    }\n    function cleanup() {\n      Helper.removeEventListeners([listener]);\n      clearTimeout(eventTimeout);\n    }\n    return promise;\n  }\n}\n\n/**\n * @param {*} value\n * @param {string=} message\n */\nfunction assert(value, message) {\n  if (!value)\n    throw new Error(message);\n}\n\nmodule.exports = {\n  helper: Helper,\n  assert,\n  debugError\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = ws;"],"sourceRoot":""}